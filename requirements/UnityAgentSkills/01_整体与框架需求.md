# 需求文档 - UnityAgentSkills 整体框架与插件化架构

## 0. 命名与术语约定

- 本模块名称为 `UnityAgentSkills`.
- 关键路径约定:
  - 编辑器插件代码目录: `Assets/Editor/UnityAgentSkills/`.
  - 数据目录: `Assets/UnityAgentSkills/`.

## 0.1 架构约束摘要

- 框架采用两层隔离架构:
  - 内置层(priority 0,硬编码注册,不依赖反射): 命名空间为 `log.*`,至少包含 `log.query`,`log.screenshot`.
  - 反射插件层: `prefab.*`,`k3prefab.*` 等.
- Log 插件层的特殊约束:
  - `LogCommandsPlugin` 可以存在,但不得在其 `RegisterHandlers()` 中注册 `log.*` 命令,避免覆盖内置层的注册优先级.
- 新增非 `log.*` 命令的最小步骤:
  - 创建 Handler.
  - 创建 Plugin,在 `RegisterHandlers()` 中注册命令.

---

## 1. 项目现状与核心目标

本需求用于实现一个 Unity Editor 插件(编辑器侧常驻工具),在 Unity 启动后自动运行,监听项目内 `Assets/UnityAgentSkills/pending/` 目录新增的 `.json` 命令文件,并以"先写处理中结果,再写最终结果,最后归档命令文件"的方式可靠地完成命令处理.

### 1.1 系统提供的命令类型包括

**通用能力**:

- `log.query` - Unity 日志查询
- `prefab.queryHierarchy` - 预制体层级查询
- `prefab.queryComponents` - 预制体组件查询
- `prefab.setGameObjectProperties` - GameObject 属性修改

**项目专用能力 (K3 框架)**:

- `k3prefab.queryByK3Id` - 通过 K3ID 查询 K3 组件
- `k3prefab.setComponentProperties` - 修改 K3 组件属性

### 1.2 插件化架构(目标)

系统采用插件化架构,其目标包括:

- 插件化扩展: 新增命令时仅需新增 Handler 与 Plugin,不修改核心执行链路.
- 故障隔离: 反射插件加载失败不得影响内置层(`log.*`)命令可用性.
- 可移植性: 删除项目专用插件目录后,项目仍可编译运行.
- 能力管理: 能力的新增/删除以文件夹为单位,对外 pending/results/done 协议保持不变.

已知项目惯例/可参考点(用于实现阶段对齐):

- 项目内已有 `[InitializeOnLoad]` 方式自动启动 Editor 功能的案例.
- 项目内日志规范存在 `GameLog`(输出到 Unity Console)等实现.

## 2. 范围与边界

### 2.1 插件化目录结构

**目录约定(必须):**

```
Assets/Editor/UnityAgentSkills/
├── Core/                              # 核心框架层
│   ├── ICommandPlugin.cs              # 插件接口定义
│   ├── CommandPluginAttribute.cs      # 插件标记特性
│   ├── CommandPluginLoader.cs         # 插件加载器
│   ├── CoreCommandsLoader.cs          # 核心命令加载器 (硬编码保护)
│   ├── CommandHandlerRegistry.cs      # 命令注册表
│   ├── PluginLoadResult.cs            # 插件加载结果模型
│   ├── BatchCommandParser.cs          # 批量命令解析
│   ├── BatchCommandExecutor.cs        # 批量命令执行
│   ├── BatchResultWriter.cs           # 批量结果写入
│   ├── CommandErrorFactory.cs         # 错误工厂
│   ├── CommandParams.cs               # 命令参数校验
│   └── AgentCommandModels.cs          # 核心数据模型
├── Plugins/                           # 插件层
│   ├── Log/                           # 日志命令插件
│   │   ├── LogCommandsPlugin.cs
│   │   └── Handlers/
│   │       └── LogQueryCommandHandler.cs
│   ├── Prefab/                        # 预制体命令插件
│   │   ├── PrefabCommandsPlugin.cs
│   │   └── Handlers/
│   │       ├── PrefabQueryHierarchyHandler.cs
│   │       ├── PrefabQueryComponentsHandler.cs
│   │       └── PrefabSetGameObjectPropertiesHandler.cs
│   └── K3Prefab/                      # K3 框架专用插件 (可移除)
│       ├── K3PrefabPlugin.cs
│       ├── Handlers/
│       │   ├── K3PrefabQueryByK3IdHandler.cs
│       │   └── K3PrefabSetComponentPropertiesHandler.cs
│       ├── Utils/                     # K3 工具类
│       └── Models/                    # K3 数据模型
├── Utils/                             # 通用工具 (保持不变)
├── SkillsExporter/                    # 技能导出配置管理
│   ├── SkillsExporterMenuItem.cs      # 菜单项（向后兼容）
│   └── SkillConfigs/                  # 技能配置目录
│       ├── SkillConfigsRegistry.cs    # 集中配置
│       ├── SkillConfig_UnityLog.cs    # 日志(查询+截图)技能配置
│       ├── SkillConfig_UnityPrefabView.cs  # 预制体查看技能配置
│       ├── SkillConfig_UnityK3Prefab.cs    # K3预制体技能配置
│       └── PythonScriptTemplate.cs    # Python脚本模板
├── UI/                                # 【新增】轻量化UI架构
│   ├── SkillsExporterWindow.cs        # 主窗口（使用TabContentManager管理tabs）
│   ├── Components/
│   │   ├── ITabContent.cs             # Tab内容接口
│   │   └── TabContentManager.cs       # Tab管理器
│   └── Tabs/                          # 各个Tab页面实现
│       ├── SkillsExportTab.cs         # 技能导出Tab（实现ITabContent）
│       └── AutoCompileTab.cs          # AutoCompile配置Tab（实现ITabContent）
├── AutoCompile/                       # AutoCompile服务
│   ├── AutoCompileService.cs          # 服务启动器（[InitializeOnLoad]）
│   ├── Core/
│   │   ├── AutoCompileController.cs   # 核心控制器
│   │   └── FileMonitorService.cs      # 文件监听服务
│   └── Configuration/
│       ├── AutoCompileConfig.cs       # 配置数据模型
│       └── AutoCompileConfigProvider.cs # EditorPrefs读写工具
├── UnityAgentSkillsConfig.cs          # 配置常量
└── UnityAgentSkillsPlugin.cs          # 主入口

Assets/UnityAgentSkills/               # 工作目录(数据目录)
├── pending/                           # 输入队列
├── results/                           # 输出结果,最多保留最近 20 条
└── done/                              # 归档备份,平铺存放
```

### 2.2 两层隔离架构

**核心理念**: 日志命令(log._)属于内置层,硬编码注册不依赖反射. 当前内置命令至少包含: log.query, log.screenshot. 其他所有命令(包括 Unity 通用的 prefab._)都通过反射插件机制加载.

**⚠️ 重要说明**:

- log.query, log.screenshot 是内置命令,硬编码注册在 `CoreCommandsLoader` 中,priority 0,永不依赖反射
- 原则上不新增非 log.\* 的内置命令(如 system.status,plugin.list),避免增加维护成本
- Log 插件的特殊性在于: 虽然代码结构也是 Plugin 类,但不会被反射扫描,只在 CoreCommandsLoader 中硬编码注册
- 所有其他命令(prefab._,k3prefab._,未来新增的 asset.\*)都通过反射插件机制加载

**内置层**(Built-in Layer - priority 0):

- `log.query` - 日志查询(内置命令,核心调试能力)
- `log.screenshot` - 日志截图(内置命令,辅助问题定位)
- 特点:
  - 硬编码注册,永不依赖反射
  - 永不失败(指命令注册与框架可用性),是框架的基础设施
  - 用于调试所有其他能力
  - LogCommandsPlugin 类存在但 RegisterHandlers() 为空实现,避免重复注册

**反射插件层** (Plugin Layer - Priority 10-100+):

- `prefab.*` - 预制体相关命令 (Unity 通用能力,Priority 20)
- `k3prefab.*` - K3 框架专用命令 (项目专用,Priority 100)
- 未来扩展命令 (如 asset.\*, Priority 30)
- 特点:
  - 通过反射自动发现,使用 [CommandPlugin] 特性标记
  - 异常隔离,单个插件失败不影响其他插件和内置命令
  - 失败时仍可使用 log.query 查看错误日志
  - 完全可移除,删除文件夹不影响项目编译 (特别是项目专用插件)

### 2.3 数据目录约定

**工作目录(数据目录):** `Assets/UnityAgentSkills/`

**数据子目录(若不存在必须自动创建):**

**功能点(本期必须):**

- [ ] Unity Editor 启动后自动启动插件,并开始监听 `pending/`.
- [ ] 启动/重启(域重载)时,自动扫描 `pending/` 中未完成的 json,继续处理.
- [ ] 发现 `pending/` 中存在待处理 json 时,按“单线程串行”策略处理(同时最多 1 个命令).
- [ ] 每个命令开始处理时,先在 `results/` 写入“半成品(处理中)json”作为处理中的标识.
- [ ] 处理完成后,覆盖写入 `results/` 中对应 json 为最终结果.
- [ ] 处理成功或失败后,将 `pending/` 中对应 json 移动到 `done/` 归档.
- [ ] 插件整体采用模块化/插件化架构,命令按 `type` 分发到不同处理器.

**非功能性要求(本期必须):**

- [ ] 域重载安全: 不产生线程溢出/内存溢出,不产生重复注册的回调,不导致编辑器卡死.
- [ ] 禁止重复注册: 任何 `FileSystemWatcher`,`EditorApplication.update`,`Application.logMessageReceived` 等回调注册必须保证幂等(例如先反注册再注册,或使用静态标记),避免域重载后重复触发导致重复处理/性能问题.
- [ ] 稳定性: 即使处理中崩溃/重启,也能通过 `pending/` + `results/` 状态恢复并继续.
- [ ] 可审计: `results/` 中结果必须包含清晰的状态与时间信息(便于排查).

**排除项(本期明确不做):**

- 不实现运行时(Play 模式或打包后)命令处理,仅限 Unity Editor.
- 不实现跨机器通信,只基于项目目录的文件输入输出.
- 不实现“并发处理多个命令”.
- 不实现日志的“跨启动回溯文件查询”(只查本次编辑器启动后的实时日志缓存).

## 3. 命令文件协议(输入 pending json)

**重要说明**: 本插件**仅支持批量命令格式**,即使只执行一个命令也必须使用批量格式.

**文件位置与后缀:**

- 输入文件必须放在 `Assets/UnityAgentSkills/pending/`.
- 后缀必须是 `.json`.

**文件命名规则(必须):**

- 文件名必须为 `{batchId}.json`,其中 `batchId` 即文件名去掉 `.json` 的部分.
- 插件以文件名解析得到 `batchId`,json 内容中不要求提供 `batchId` 字段.

**batchId 生成建议(建议):**

- `batchId` 由写入 pending json 的外部工具/Agent 生成,不要求有序,只要求全局尽量不重复.
- 只包含文件名安全字符(推荐 `[a-zA-Z0-9_-]`),避免空格与特殊字符.
- 推荐长度: 16-32 个字符.
- 示例: `batch_log_001`, `batch_error_qa2k3m9x`.

**最小字段(必须):**

- `batchId`: string,批次唯一标识,用作文件名 `{batchId}.json`.
- `commands`: array,必填.命令数组,每个元素是一个完整的命令对象.

**命令对象字段(每个元素):**

- `id`: string,必填.命令唯一标识,由调用方提供,用于在结果中匹配每个命令.
- `type`: string,必填.命令类型,用于分发处理器.首期定义 `log.query`.
- `params`: object,必填.命令参数,具体内容由命令类型决定.
- `timeout`: number,可选.命令级别超时时间(毫秒),优先级高于批次级别,默认 null(使用批次级别值).

**批次级别字段(可选):**

- `timeout`: number,可选.批次级别超时时间(毫秒),默认 30000(30 秒).

**时间戳来源(必须):**

- pending json 不再要求提供 `createdAt` 字段.
- 插件以命令文件的文件系统元数据作为审计与排序参考:
  - 优先使用文件创建时间(CreationTime).
  - 若无法可靠获取,使用最后写入时间(LastWriteTime)作为兜底.

**写入未完成重试(必须):**

- 为避免外部工具“先创建文件,再分段写入内容”导致短暂的不可解析,插件在读取 pending 文件失败时必须重试(轻量指数退避):
  - 该重试参数为实现层常量(例如 `ReadRetryDelaysMs=[1000,2000,4000]`),可由开发者在代码中调整(本期默认如示例).
  - 最多重试 3 次.
  - 间隔依次为: 1000ms,2000ms,4000ms.
  - 若重试后仍不可解析,才按 `INVALID_JSON` 处理并归档.

**文件命名规则(必须):**

- 文件名必须为 `{id}.json`,其中 `id` 即文件名去掉 `.json` 的部分.
- 插件以文件名解析得到 `id`,json 内容中不要求提供 `id` 字段.

**id 生成建议(建议):**

- `id` 由写入 pending json 的外部工具/Agent 生成,不要求有序,只要求全局尽量不重复.
- 不要求日期前缀(因为 done 不再按日期分组,且旧记录会被自动清理).
- 建议使用随机 ID,且只包含文件名安全字符(推荐 `[a-zA-Z0-9_-]`),避免空格与特殊字符.
- 推荐长度: 16-32 个字符.
- 示例(任选一种风格,保持一致):
  - 类 nanoid 风格: `pD3k9aQm_7F2wXbTn1c8`.

## 4. 结果文件协议(输出 results json)

**文件位置:** `Assets/UnityAgentSkills/results/`.

**文件命名(必须):**

- `results/{batchId}.json`.

**批次级别结果结构(必须):**

- `batchId`: string,批次唯一标识(与输入一致).
- `status`: string,批次状态,仅允许:
  - `processing`: 批次正在执行中.
  - `completed`: 批次执行完成(包括全部成功或部分成功).
  - `error`: 批次级别错误(如 JSON 解析失败,字段缺失等).
- `startedAt`: string,批次开始执行时间戳.
- `finishedAt`: string,批次完成执行时间戳.
- `results`: array,命令结果数组,顺序与输入 `commands` 顺序一致.
- `totalCommands`: number,总命令数.
- `successCount`: number,成功执行的命令数.
- `failedCount`: number,失败的命令数.
- `error`: object,仅在 `status=error` 时必须存在:
  - `code`: string,可用于分类(例如 `INVALID_JSON`,`INVALID_FIELDS`,`UNKNOWN_TYPE`).
  - `message`: string,对非专业人士可读的错误说明.
  - `detail`: string,可选,用于开发排查的额外信息.

**命令级别结果结构(results 数组中每个元素):**

- `id`: string,命令唯一标识(与输入一致).
- `type`: string,命令类型(与输入一致).
- `status`: string,命令状态.
  - 最终结果仅允许:
    - `success`: 命令执行成功.
    - `error`: 命令执行失败.
  - 处理中(可选): 当 batch 处于 `status=processing` 且实现需要跨帧推进时,允许命令级 `status` 暂时为空字符串(占位).占位表示该命令尚未完成,最终写入 `completed` 时必须变为 `success` 或 `error`.
- `startedAt`: string,命令开始执行时间戳.
- `finishedAt`: string,命令完成执行时间戳.
- `result`: object,可选.命令执行成功时的结果数据,内容由命令类型决定.
- `error`: object,可选.命令执行失败时的错误信息,包含:
  - `code`: string,错误码(如 `INVALID_FIELDS`,`INVALID_REGEX`,`TIMEOUT`,`SKIPPED` 等).
  - `message`: string,对非专业人士可读的错误说明.
  - `detail`: string,可选.详细的错误信息或堆栈.

**半成品(处理中)规则(必须):**

- `results/` 中最多保留最近 20 条最终结果(success/error). 当写入新的最终结果后,如果超出 20 条,必须删除最老的结果文件.

  - 同时删除 `done/` 中同名归档命令文件(即原始 pending json 的备份).
  - 该 20 为实现层常量(例如 `MaxResults=20`),可由开发者在代码中调整(本期默认 20).
  - 仅对最终结果(success/error)参与计数与清理,`processing` 不参与计数,避免处理中被误删.
  - “最老”按 `results/{id}.json` 的文件创建时间(CreationTime)判断(若无法可靠获取,用 LastWriteTime 兜底).

- 在域重载后重新启动插件时,如果发现 `pending/` 仍存在同一个命令文件,则允许覆盖 `results/{id}.json` 为新的 `processing`(表示继续处理).
- 为避免外部读取到半截 json,写入 results 建议采用原子写: 先写临时文件(例如 `.tmp`),再 rename 覆盖为最终文件.

**JSON 格式化输出(必须):**

- 返回的 JSON 必须格式化输出,分好行,而非压缩在一行中.
- 是否折叠输出通过代码配置项控制(并非用户配置或请求是可选):
  - 配置项: `UnityAgentSkillsConfig.PrettyPrintJson`
  - 默认值: `true` (不折叠,格式化输出)
  - 实现方式: 使用 LitJson2_utf.JsonWriter 的 PrettyPrint 属性,不引入其他库.

**常量配置(实现要求):**

- 需要将 `MaxResults`、`ReadRetryDelaysMs` 和 `PrettyPrintJson` 等参数集中放在单独的 C# 文件中(例如 `UnityAgentSkillsConfig.cs`),以便开发者调整(不提供外部配置文件).

## 5. 文件流转与状态机

**处理顺序(必须):**

- 单线程串行处理.一次只处理一个批次文件.
- 当 `pending/` 同时存在多个文件,按"文件创建时间从早到晚"处理(若无法可靠获取,则按文件名排序作为兜底,实现阶段需注明).
- 批次内的命令严格按照 `commands` 数组的顺序串行执行,不并行.

**处理流程(必须):**

1. 发现待处理 `pending/{batchId}.json`.
2. 读取并解析 json.
3. 若 json 不可解析,或缺少最小字段(例如缺 `batchId`/`commands`):
   - 直接写入 `results/{batchId}.json` 为 `status=error`(不写 processing),用于告知外部"命令文件格式不正确\".
   - `error.code` 使用 `INVALID_JSON` 或 `INVALID_FIELDS`.
   - 然后将 `pending/{batchId}.json` 移动到 `done/{batchId}.json` 归档.
4. 若校验通过,写入 `results/{batchId}.json` 半成品: `status=processing`, `results=[]`.
5. 串行执行批次内的每个命令:
   - 按顺序执行 `commands` 数组中的每个命令.
   - 每个命令开始时,记录 `startedAt`.
   - 执行成功时,记录 `finishedAt`,添加 `status=success` 和 `result` 到 `results` 数组.
   - 执行失败时,记录 `finishedAt`,添加 `status=error` 和 `error` 到 `results` 数组.
   - **部分成功模式**: 某个命令失败不影响后续命令执行,继续执行剩余命令.
   - **超时处理**:
     - 如果单个命令执行时间超过其 `timeout`,该命令失败(`TIMEOUT` 错误),继续执行后续命令.
     - 如果整个批次执行时间超过批次级别 `timeout`,立即中止执行,未执行的命令标记为 `SKIPPED` 错误.
6. 所有命令执行完毕或批次超时后:
   - 覆盖写入 `results/{batchId}.json` 为 `status=completed`,包含完整的 `results` 数组和统计信息(`totalCommands`,`successCount`,`failedCount`).
7. 无论成功或失败,将 `pending/{batchId}.json` 移动到 `done/{batchId}.json`.

**恢复机制(必须):**

- Unity Editor 启动/脚本重编译后插件重新加载时,必须扫描 `pending/`:
  - 如果存在文件,说明命令尚未归档,必须继续处理.
  - 即使 `results/{batchId}.json` 已存在并且是 `processing`,也必须以当前重启为准继续处理,并可覆盖更新 `startedAt`.

## 6. 模块化/可扩展性要求

### 6.1 命令分发机制(必须)

- 命令分发按 `type` 查找对应的命令处理器.
- 每个处理器只负责:
  - 解析与校验自己的 `params`.
  - 执行业务逻辑.
  - 构造 `result` 或 `error`.
- 所有命令处理器由 `CommandHandlerRegistry` 统一注册与管理.

### 6.2 插件化扩展方式(必须)

新增非 `log.*` 命令时,只需要 2 步:

1. 创建 Handler,并暴露一个统一的 `Execute(params)` 入口.
2. 创建 Plugin,在 `RegisterHandlers()` 中注册 `type -> handler` 的映射.

约束:

- `log.*` 命令属于内置层,必须由 `CoreCommandsLoader` 以 priority 0 硬编码注册,不得在插件层重复注册.

**步骤 3**: 大功完成

- 重新编译 C# 脚本
- Unity 域重载后插件自动发现并注册
- 无需修改任何核心文件

**删除命令流程简化**:

- 直接删除对应的插件文件夹 (如 `Plugins/Asset/`)
- 下次域重载时自动卸载,无需清理注册表

### 6.3 插件接口定义

**ICommandPlugin 接口** (实际代码):

```csharp
namespace UnityAgentSkills.Core
{
    public interface ICommandPlugin
    {
        string Name { get; }
        void RegisterHandlers(CommandHandlerRegistry registry);
        void Initialize();
        void Shutdown();
    }
}
```

**CommandPlugin 特性** (实际代码):

```csharp
[AttributeUsage(AttributeTargets.Class)]
public class CommandPluginAttribute : Attribute
{
    public string Name { get; set; }
    public int Priority { get; set; }

    public CommandPluginAttribute(string name, int priority = 100)
    {
        if (string.IsNullOrWhiteSpace(name))
        {
            throw new ArgumentException("插件名称不能为空", nameof(name));
        }
        Name = name;
        Priority = priority;
    }
}
```

**实际实现要点**:

- CommandPlugin 特性的构造函数要求 `name` 参数为必填
- Priority 默认值为 100
- 如果插件名称为空会抛出 ArgumentException
- Log 插件实际使用: `[CommandPlugin("Log", Priority = 10)]`

### 6.4 故障隔离机制

**插件加载隔离**:

- 每个插件在独立的 try-catch 块中加载
- 一个插件失败只记录警告,不影响后续插件
- CommandPluginLoader 会记录每个插件注册的命令清单和优先级

**内置命令保护**:

- 内置命令(log.\*)优先加载,加载失败时框架进入"降级模式"
- 内置命令失败 → 记录严重错误,框架不可用,CriticalFailure = true
- 插件命令失败 → 框架正常,但部分功能不可用

**调试能力保障**:

- 即使所有插件都加载失败,log.query 仍可用(同时 log.screenshot 也应可用)
- 开发者可用 log.query 查看错误日志,定位插件加载失败原因
- PluginLoadResult 提供详细的加载状态信息:
  - SuccessfulPlugins: 成功加载的插件列表
  - FailedPlugins: 失败的插件及原因
  - PluginCommands: 每个插件注册的命令清单
  - PluginPriorities: 每个插件的优先级
  - GetStatusSummary(): 框架状态简要描述

**系统程序集过滤**:

- CommandPluginLoader 会自动跳过系统程序集 (Unity*, UnityEngine*, System*, Microsoft*, mscorlib*, netstandard*)
- 只扫描用户自定义程序集中的插件类
- 扫描失败不会中断整体加载流程

### 6.5 可移植性支持

**无依赖编译**:

- 删除 `K3Prefab/` 文件夹后项目可正常编译
- `CommandHandlerRegistry` 不再直接引用 `UnityAgentSkills.K3Prefab.Handlers`
- 所有项目专用引用通过接口解耦

**配置文件控制** (可选):

- 支持 `plugins.json` 配置文件
- 支持 `enabledPlugins` 列表 (显式启用)
- 支持 `disabledPlugins` 列表 (显式禁用)
- 配置文件不存在时,默认自动发现所有插件

## 7. 举例覆盖需求和边缘情况(框架通用)

**例 1: 批量执行多个日志查询命令(全部成功)**

- pending 输入:

```json
{
  "batchId": "batch_error_logs_001",
  "timeout": 60000,
  "commands": [
    {
      "id": "cmd_query_error_50",
      "type": "log.query",
      "params": {
        "n": 50,
        "level": "Error",
        "includeStack": true
      }
    },
    {
      "id": "cmd_query_warning_100",
      "type": "log.query",
      "params": {
        "n": 100,
        "level": "Warning",
        "includeStack": false
      }
    }
  ]
}
```

- 预期 results:
  - `results` 数组包含 2 个元素,顺序与输入一致.
  - `results[0]`: Error 日志查询结果.
  - `results[1]`: Warning 日志查询结果.
  - `totalCommands = 2`, `successCount = 2`, `failedCount = 0`.

**例 2: 部分成功(某些命令失败)**

- pending 输入:

```json
{
  "batchId": "batch_partial_001",
  "commands": [
    {
      "id": "cmd_001",
      "type": "log.query",
      "params": { "n": 10, "level": "Error" }
    },
    {
      "id": "cmd_002",
      "type": "log.query",
      "params": {
        "n": 20,
        "keyword": "[invalid",
        "matchMode": "Regex"
      }
    },
    {
      "id": "cmd_003",
      "type": "log.query",
      "params": { "n": 30, "level": "Warning" }
    }
  ]
}
```

- 预期:
  - `cmd_001`: 成功.
  - `cmd_002`: 失败(正则非法,`INVALID_REGEX`).
  - `cmd_003`: 成功.
  - `totalCommands = 3`, `successCount = 2`, `failedCount = 1`.

**例 3: 命令超时后继续执行**

- pending 输入:

```json
{
  "batchId": "batch_timeout_001",
  "timeout": 30000,
  "commands": [
    {
      "id": "cmd_fast",
      "type": "log.query",
      "params": { "n": 10 },
      "timeout": 5000
    },
    {
      "id": "cmd_normal",
      "type": "log.query",
      "params": { "n": 100 }
    },
    {
      "id": "cmd_slow",
      "type": "log.query",
      "params": { "n": 5000 },
      "timeout": 60000
    }
  ]
}
```

- 预期:
  - `cmd_fast`: 使用命令级别超时 5000ms.
  - `cmd_normal`: 使用批次级别超时 30000ms.
  - `cmd_slow`: 使用命令级别超时 60000ms.
  - 如果 `cmd_normal` 执行超时,该命令失败,但继续执行 `cmd_slow`.

**例 4: 批次级别超时,部分命令未执行**

- pending 输入:

```json
{
  "batchId": "batch_timeout_all_001",
  "timeout": 5000,
  "commands": [
    { "id": "cmd_001", "type": "log.query", "params": { "n": 10 } },
    { "id": "cmd_002", "type": "log.query", "params": { "n": 100 } },
    { "id": "cmd_003", "type": "log.query", "params": { "n": 1000 } },
    { "id": "cmd_004", "type": "log.query", "params": { "n": 10000 } }
  ]
}
```

- 预期:
  - 批次总执行时间超过 5000ms 时立即中止.
  - `cmd_001`, `cmd_002`: 成功.
  - `cmd_003`: 超时失败(`TIMEOUT`).
  - `cmd_004`: 未执行(`SKIPPED`).

**例 5: json 文件写入未完成就被监听到**

- 场景:
  - 外部程序正在写 `pending/cmd_002.json`,Unity 监听到 Created/Changed 事件时文件内容还不完整.
- 预期:
  - 插件应具备"重试/延迟处理"策略,避免因为短暂的半写入导致永久失败.

**例 6: 域重载中断处理**

- 场景:
  - 已写出 `results/cmd_003.json` 为 `processing`,但 Unity 因脚本重编译域重载.
- 预期:
  - 重启后扫描 `pending/` 仍发现 `cmd_003.json`,继续处理并最终归档.

**例 7: 未知 type**

- pending 输入:

```json
{
  "batchId": "batch_unknown_type_001",
  "commands": [
    {
      "id": "cmd_001",
      "type": "log.query",
      "params": { "n": 50 }
    },
    {
      "id": "cmd_002",
      "type": "unknown.command",
      "params": {}
    }
  ]
}
```

- 预期:
  - `cmd_001`: 成功.
  - `cmd_002`: 失败,错误码 `UNKNOWN_TYPE`.

## 8. 验收清单

### 8.1 核心框架验收

- [ ] 创建 `ICommandPlugin` 接口,包含 Name, RegisterHandlers, Initialize, Shutdown 方法
- [ ] 创建 `[CommandPlugin]` 特性,支持 Name 和 Priority 参数
- [ ] 创建 `CommandPluginLoader` 类,实现反射扫描和插件加载
- [ ] 创建 `CoreCommandsLoader` 类,硬编码注册核心命令(至少 log.query,log.screenshot)
- [ ] 重构 `CommandHandlerRegistry` 类,移除硬编码的 Handler 引用

### 8.2 插件实现验收

- [ ] 创建 `LogCommandsPlugin` 类,但 RegisterHandlers() 为空实现(log.\* 已在 CoreCommandsLoader 中硬编码)
- [ ] 创建 `PrefabCommandsPlugin` 类,注册所有 `prefab.*` 命令
- [ ] 创建 `K3PrefabPlugin` 类,注册所有 `k3prefab.*` 命令

### 8.3 故障隔离验收

- [ ] 插件加载失败时,不影响其他插件加载
- [ ] 插件加载失败时,核心命令仍可用
- [ ] 核心命令加载失败时,框架进入"不可用状态"
- [ ] 所有加载失败信息写入 `plugin_errors.json` (如实现)

### 8.4 能力管理验收

- [ ] 新增命令只需要创建 Handler + Plugin,无需修改核心文件
- [ ] 删除 `K3Prefab/` 文件夹后项目可正常编译运行
- [ ] 删除 `K3Prefab/` 文件夹后,k3prefab.\* 命令不存在

### 8.5 功能回归验收

- [ ] 删除 `Assets/UnityAgentSkills/` 后重新打开 Unity,目录会自动创建完整.
- [ ] 往 `pending/` 放入 1 个合法批量命令 json,json 会被处理,`results/` 先出现 processing 再变 completed,命令文件被移动到 `done/`.
- [ ] 批量命令执行后,`results` 数组顺序与输入 `commands` 数组顺序完全一致.
- [ ] 批量命令的批次级别统计字段正确: `totalCommands`,`successCount`,`failedCount`.
- [ ] 部分成功模式: 某个命令失败时,后续命令继续执行,最终返回所有结果.
- [ ] 命令级别 `timeout` 优先级高于批次级别 `timeout`.
- [ ] 命令超时时,该命令失败,但继续执行后续命令.
- [ ] 批次超时时,立即中止执行,返回已完成命令的结果,未执行命令标记为 `SKIPPED` 错误.
- [ ] 命令缺少必填字段时,该命令失败,不影响后续命令.
- [ ] 未知命令类型时,该命令失败,错误码 `UNKNOWN_TYPE`.
- [ ] 正则表达式非法时,该命令失败,错误码 `INVALID_REGEX`.
- [ ] `commands` 数组为空时,批次级别错误,错误码 `INVALID_FIELDS`.
- [ ] `batchId` 字段缺失时,批次级别错误,错误码 `INVALID_FIELDS`.
- [ ] 单个命令也必须使用批量格式(包含 `commands` 数组).
- [ ] 批量执行多个命令时,严格按输入顺序串行执行,不并行.
- [ ] 在处理过程中触发域重载(例如修改脚本触发重编译),插件重启后能继续处理并最终归档.
- [ ] 连续放入 21 个合法批量命令并等待全部处理完成,当第 21 个命令完成后,最老的 1 个 results 和对应的 done 同名归档会被自动删除(results 中始终保留最新的 20 条最终结果).
- [ ] 在处理过程中检查 `results/` 目录,即使已有 20 条或更多结果,`processing` 状态的结果文件也不会被清理;只有 `completed` 的最终结果才参与计数和清理.

### 8.6 可移植性验收

- [ ] 移除 `K3Prefab/` 文件夹后,项目编译无错误
- [ ] 移除 `K3Prefab/` 文件夹后,Unity 启动无错误
- [ ] 移除 `K3Prefab/` 文件夹后,其他命令功能正常

### 8.7 文档和注释验收

- [ ] 所有新增的类都有 XML 文档注释
- [ ] 插件接口和特性有使用示例
- [ ] 核心代码有详细的设计说明注释
- [ ] 需求文档已更新,说明插件化架构

---

## 9. 相关文档

- `02_日志功能需求_log.md`: 日志相关内置命令(`log.query`,`log.screenshot`)的需求与验收口径.
- `03_预制体查看.md`: `prefab.view` 的需求与验收口径.
- `04_预制体编辑01.md` / `04_预制体编辑02.md`: 预制体编辑相关命令的需求与验收口径.
- `99_用户界面插件与skill和脚本生成.md`: SkillsExporter 的需求与约束.
