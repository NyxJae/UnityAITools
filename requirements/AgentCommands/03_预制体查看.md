# 需求文档 - 预制体查看功能

## 1. 项目现状与核心目标

### 1.1 用户需求简述

需要提供两个命令来查询 Unity 预制体的信息：

1. **prefab.queryHierarchy**: 查询预制体内所有 GameObject 的层级结构
2. **prefab.queryComponents**: 查询指定 GameObject 上所有组件的详细信息

### 1.2 项目现状

- 项目已有完善的 AgentCommands 命令系统，位于 `Code/Assets/Editor/AgentCommands/`
- 命令系统支持批量格式，通过 JSON 文件输入和输出
- 现有 `log.query` 命令可作为实现参考

## 2. 范围与边界

### 2.1 功能点简述

本需求包含以下两个独立命令：

#### 命令 1: prefab.queryHierarchy

- [ ] 接收预制体绝对路径，加载并解析预制体
- [ ] 返回预制体内所有 GameObject 的完整层级结构
- [ ] 每个 GameObject 包含：name、instanceID、path、isActive 状态、子对象列表
- [ ] 支持参数：是否包含禁用的 GameObject、最大遍历深度

#### 命令 2: prefab.queryComponents

- [ ] 接收预制体路径和 GameObject 路径，定位目标对象
- [ ] 返回该 GameObject 上所有组件的详细信息
- [ ] 每个组件包含：类型名、instanceID、所有可序列化字段
- [ ] 支持参数：组件类型过滤、是否包含 Unity 内置组件、字段详细程度控制

### 2.2 排除项

- 不支持直接编辑功能（后续需求）
- 不支持实时运行时对象查询（仅支持预制体文件）
- 不需要为每种组件单独定义关键字段规则
- 不需要预制体文本文件的 fileID（统一使用 Unity InstanceID）

## 3. 技术实现要点

### 3.1 实现方案

- 使用 Unity 的 SerializedObject 系统操作预制体
- 返回 InstanceID 用于会话中快速定位
- 同时记录对象路径作为稳定引用方式
- 两个命令都遵循项目 AgentCommands 批量命令格式

### 3.2 数据格式

- **输入格式**：遵循 `batchId`, `timeout`, `commands[]` 的批量格式
- **输出格式**：遵循 `results[]`, `status`, `startedAt`, `finishedAt` 的统一响应格式

### 3.3 架构设计要求（为后续扩展准备）

**模块化设计原则**：

- 代码编写时必须采用高度模块化的设计，便于后续扩展到编辑功能和更多资源类型
- 避免将预制体查询的逻辑硬编码在命令处理器中，应抽取为可复用的工具类
- 组件属性读取、层级遍历、对象定位等核心逻辑应独立封装

**可复用性要求**：

- **对象加载与定位模块**：封装通用的预制体加载、实例化、路径定位逻辑
- **SerializedObject 操作模块**：封装统一的属性读取、类型转换、JSON 序列化逻辑
- **层级遍历模块**：封装递归遍历 GameObject 树的工具方法
- **组件查询模块**：封装组件类型过滤、属性过滤的通用逻辑

**后续扩展考虑**：

- 预制体编辑功能（修改组件参数、添加/删除组件等）
- 资产文件查看与编辑（.asset、.shader、.mat、.anim 等）
- 场景文件查询（.unity 场景中的对象层级和组件）
- 资源依赖分析（查询预制体引用的资源文件）

**代码组织建议**：

```
Assets/Editor/AgentCommands/
├── Core/
│   ├── CommandHandlerRegistry.cs       # 命令注册表（已有）
│   ├── CommandParams.cs                 # 参数读取工具（已有）
│   └── ...
├── Handlers/
│   ├── PrefabQueryHierarchyHandler.cs   # 预制体层级查询
│   ├── PrefabQueryComponentsHandler.cs  # 预制体组件查询
│   └── LogQueryCommandHandler.cs        # 日志查询（已有）
├── Utils/                                # 【新增】通用工具模块
│   ├── SerializedObjectHelper.cs        # SerializedObject操作工具
│   ├── GameObjectPathFinder.cs          # GameObject路径定位工具
│   ├── HierarchyTraverser.cs            # 层级遍历工具
│   ├── ComponentPropertyReader.cs       # 组件属性读取工具
│   └── PrefabLoader.cs                  # 预制体加载工具
└── Models/                               # 【新增】数据模型
    └── PropertyTypes.cs                 # 属性类型定义
```

**技术选型说明**：

- 使用 Unity 的 SerializedObject 系统：可以统一访问所有可序列化的对象属性
- 不仅适用于预制体，也适用于 .asset、.shader、.mat 等所有 Unity 可序列化的资源
- 为后续编辑功能提供基础：SerializedObject 同时支持读取和写入属性

## 4. 举例覆盖需求和边缘情况

### 4.1 命令 1: prefab.queryHierarchy 示例

#### 输入示例

```json
{
  "batchId": "query_hierarchy_001",
  "timeout": 30000,
  "commands": [
    {
      "id": "cmd_get_hierarchy",
      "type": "prefab.queryHierarchy",
      "params": {
        "prefabPath": "Assets/resourcesab/uiprefabs/DialogMain.prefab",
        "includeInactive": true,
        "maxDepth": -1
      }
    }
  ]
}
```

#### 输出示例

```json
{
  "batchId": "query_hierarchy_001",
  "status": "completed",
  "startedAt": "2026-01-29 20:00:00.000",
  "finishedAt": "2026-01-29 20:00:00.500",
  "results": [
    {
      "id": "cmd_get_hierarchy",
      "type": "prefab.queryHierarchy",
      "status": "success",
      "startedAt": "2026-01-29 20:00:00.100",
      "finishedAt": "2026-01-29 20:00:00.400",
      "result": {
        "prefabPath": "Assets/resourcesab/uiprefabs/DialogMain.prefab",
        "rootName": "DialogMain",
        "totalGameObjects": 15,
        "hierarchy": [
          {
            "name": "DialogMain",
            "instanceID": 123456789,
            "path": "DialogMain",
            "depth": 0,
            "isActive": true,
            "children": [
              {
                "name": "Panel_Content",
                "instanceID": 234567890,
                "path": "DialogMain/Panel_Content",
                "depth": 1,
                "isActive": true,
                "children": [
                  {
                    "name": "K3Button_Confirm",
                    "instanceID": 345678901,
                    "path": "DialogMain/Panel_Content/K3Button_Confirm",
                    "depth": 2,
                    "isActive": true,
                    "children": []
                  },
                  {
                    "name": "K3Label_Title",
                    "instanceID": 456789012,
                    "path": "DialogMain/Panel_Content/K3Label_Title",
                    "depth": 2,
                    "isActive": false,
                    "children": []
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  ],
  "totalCommands": 1,
  "successCount": 1,
  "failedCount": 0
}
```

#### 边缘情况示例

**例 1: 路径不存在的预制体**

```json
{
  "batchId": "test_invalid_path",
  "commands": [
    {
      "id": "cmd_invalid",
      "type": "prefab.queryHierarchy",
      "params": {
        "prefabPath": "Assets/notexist.prefab"
      }
    }
  ]
}
```

预期返回：`status: "failed"`, `error: "Prefab not found at path: Assets/notexist.prefab"`

**例 2: 限制深度遍历**

```json
{
  "params": {
    "prefabPath": "Assets/resourcesab/uiprefabs/DialogMain.prefab",
    "maxDepth": 2
  }
}
```

预期返回：只返回深度 ≤2 的 GameObject，更深层的对象不包含

**例 3: 只包含活跃的 GameObject**

```json
{
  "params": {
    "prefabPath": "Assets/resourcesab/uiprefabs/DialogMain.prefab",
    "includeInactive": false
  }
}
```

预期返回：过滤掉 `isActive: false` 的 GameObject 及其子对象

### 4.2 命令 2: prefab.queryComponents 示例

#### 输入示例

```json
{
  "batchId": "query_components_001",
  "timeout": 30000,
  "commands": [
    {
      "id": "cmd_get_components",
      "type": "prefab.queryComponents",
      "params": {
        "prefabPath": "Assets/resourcesab/uiprefabs/DialogMain.prefab",
        "objectPath": "DialogMain/Panel_Content/K3Button_Confirm",
        "componentFilter": ["K3Button", "RectTransform", "CanvasRenderer"],
        "includeBuiltin": true,
        "includePrivateFields": false
      }
    }
  ]
}
```

#### 输出示例

```json
{
  "batchId": "query_components_001",
  "status": "completed",
  "startedAt": "2026-01-29 20:00:00.000",
  "finishedAt": "2026-01-29 20:00:00.300",
  "results": [
    {
      "id": "cmd_get_components",
      "type": "prefab.queryComponents",
      "status": "success",
      "startedAt": "2026-01-29 20:00:00.100",
      "finishedAt": "2026-01-29 20:00:00.250",
      "result": {
        "objectPath": "DialogMain/Panel_Content/K3Button_Confirm",
        "instanceID": 345678901,
        "totalComponents": 3,
        "components": [
          {
            "type": "RectTransform",
            "instanceID": 567890123,
            "properties": {
              "anchoredPosition": { "x": 0, "y": 0 },
              "sizeDelta": { "x": 200, "y": 80 },
              "anchorMin": { "x": 0.5, "y": 0.5 },
              "anchorMax": { "x": 0.5, "y": 0.5 },
              "pivot": { "x": 0.5, "y": 0.5 }
            }
          },
          {
            "type": "CanvasRenderer",
            "instanceID": 678901234,
            "properties": {
              "cullTransparentMesh": 1
            }
          },
          {
            "type": "K3Button",
            "instanceID": 789012345,
            "scriptPath": "Assets/Scripts/HotUpdate/K3Engine/Component/K3Button.cs",
            "properties": {
              "interactable": true,
              "transitionType": 0,
              "targetGraphic": { "instanceID": 890123456 }
            }
          }
        ]
      }
    }
  ],
  "totalCommands": 1,
  "successCount": 1,
  "failedCount": 0
}
```

#### 边缘情况示例

**例 1: GameObject 路径不存在**

```json
{
  "params": {
    "prefabPath": "Assets/resourcesab/uiprefabs/DialogMain.prefab",
    "objectPath": "DialogMain/NotExistNode"
  }
}
```

预期返回：`status: "failed"`, `error: "GameObject not found at path: DialogMain/NotExistNode"`

**例 2: 不包含内置组件**

```json
{
  "params": {
    "prefabPath": "Assets/resourcesab/uiprefabs/DialogMain.prefab",
    "objectPath": "DialogMain/Panel_Content/K3Button_Confirm",
    "includeBuiltin": false
  }
}
```

预期返回：只返回 K3Button 等自定义组件，不包含 RectTransform、CanvasRenderer 等 Unity 内置组件

**例 3: 组件类型过滤**

```json
{
  "params": {
    "prefabPath": "Assets/resourcesab/uiprefabs/DialogMain.prefab",
    "objectPath": "DialogMain/Panel_Content/K3Button_Confirm",
    "componentFilter": ["K3Button"]
  }
}
```

预期返回：只返回 K3Button 组件，其他类型被过滤

**例 4: 包含私有字段**

```json
{
  "params": {
    "prefabPath": "Assets/resourcesab/uiprefabs/DialogMain.prefab",
    "objectPath": "DialogMain/Panel_Content/K3Button_Confirm",
    "includePrivateFields": true
  }
}
```

预期返回：除了公共字段外，还包含可序列化的私有字段（带 SerializeField 标记的）

**例 5: 组件无可序列化字段**

```json
{
  "result": {
    "components": [
      {
        "type": "SomeComponent",
        "instanceID": 123,
        "properties": {}
      }
    ]
  }
}
```

预期返回：properties 为空对象，但不报错

## 5. 参数汇总

### 5.1 prefab.queryHierarchy 参数

| 参数名          | 类型    | 必填 | 默认值 | 说明                      |
| --------------- | ------- | ---- | ------ | ------------------------- |
| prefabPath      | string  | 是   | -      | 预制体绝对路径            |
| includeInactive | boolean | 否   | true   | 是否包含禁用的 GameObject |
| maxDepth        | int     | 否   | -1     | 最大遍历深度，-1 表示无限 |

### 5.2 prefab.queryComponents 参数

| 参数名               | 类型     | 必填 | 默认值 | 说明                        |
| -------------------- | -------- | ---- | ------ | --------------------------- |
| prefabPath           | string   | 是   | -      | 预制体绝对路径              |
| objectPath           | string   | 是   | -      | GameObject 层级路径         |
| componentFilter      | string[] | 否   | null   | 组件类型过滤，null 表示全部 |
| includeBuiltin       | boolean  | 否   | false  | 是否包含 Unity 内置组件     |
| includePrivateFields | boolean  | 否   | false  | 是否包含私有字段            |
| includePrivateFields | boolean  | 否   | false  | 是否包含私有字段            |

## 实现过程中遇到的难题

### 嵌套属性处理问题

**问题描述**:
在`SerializedObjectHelper.GetSerializedProperties`方法中，使用`SerializedProperty.Next(false)`遍历组件属性时，会遍历到嵌套的子属性。例如：

```
m_CorrespondingSourceObject (顶层属性)
  ├── m_CorrespondingSourceObject.m_PrefabInstance (嵌套属性)
  └── m_CorrespondingSourceObject.m_PrefabAsset (嵌套属性)
```

这些嵌套属性都被作为独立的键添加到同一个 JsonData 对象中，导致生成的 JSON 格式错误：

```json
{
  "m_CorrespondingSourceObject" : "m_PrefabInstance" : "m_PrefabAsset" : {
    "instanceID" : 261436,
    "type" : "Object"
  }
}
```

这种格式不是有效的 JSON，包含重复的键名和错误的冒号语法。

**根本原因**:

- `SerializedProperty.Next(false)`会深度遍历所有序列化属性，包括嵌套属性
- 代码中直接将`prop.propertyPath`作为键添加到 JsonData 对象，没有区分顶层属性和嵌套属性
- LitJson2_utf 的 JsonData 对象允许设置重复的键，但生成的 JSON 字符串格式不正确

**可能的影响**:

1. 生成的 JSON 文件无法被正确解析
2. 可能导致 AgentCommands 的 BatchCommandExecutor 无法正确处理返回结果
3. 影响后续的预制体编辑功能，因为无法正确读取组件属性

**解决方案 (已实施 - 方案 2)**:

方案 2: 递归构建嵌套 JSON 结构 ✅

- 对于嵌套属性，递归构建子对象结构
- 优点: 保留完整属性信息
- 缺点: 实现复杂，需要处理各种特殊情况

**实施步骤**:

1. **设计 propertyPath 解析与 token 模型**

   - 定义 `PathTokenType` 枚举: Field, ArraySize, ArrayIndex (SerializedObjectHelper.cs 12-17 行)
   - 定义 `PathToken` 结构体: Type, FieldName, ArrayIndex (SerializedObjectHelper.cs 22-69 行)
   - 实现三个静态工厂方法: CreateField, CreateArraySize, CreateArrayIndex (SerializedObjectHelper.cs 31-65 行)

2. **实现 ParsePropertyPath 解析逻辑**

   - 解析 Unity 序列化属性路径为 token 列表 (SerializedObjectHelper.cs 206-283 行)
   - 支持格式: "fieldName", "array.size", "array.data[index]", "parent.array.data[0].field"
   - 处理 ".size" 格式转换为 ArraySize token (SerializedObjectHelper.cs 227-240 行)
   - 处理 ".data[index]" 格式转换为 ArrayIndex token (SerializedObjectHelper.cs 243-262 行)

3. **实现 InsertPropertyValue 插入逻辑**

   - 根据 token 列表构建嵌套 JSON 树结构 (SerializedObjectHelper.cs 390-407 行)
   - 支持对象节点创建/复用、数组扩容与占位 null
   - 遍历 token 列表, 在最后一步设置最终值

4. **优化 ConvertSerializedProperty 类型转换**

   - Generic 类型返回空对象容器, 由子属性填充 (SerializedObjectHelper.cs 366-370 行)
   - ManagedReference 返回带类型信息的容器 (SerializedObjectHelper.cs 371-377 行)
   - 避免在 default 分支返回占位符字符串

5. **集成到 GetSerializedProperties 遍历逻辑**
   - 在遍历循环中调用 InsertPropertyValue 替代直接赋值 (SerializedObjectHelper.cs 154-155 行)
   - 实现嵌套属性树结构构建, 保留完整属性信息

**关键代码位置**:

- PathTokenType 枚举定义: SerializedObjectHelper.cs 12-17 行
- PathToken 结构体定义: SerializedObjectHelper.cs 22-69 行
- ParsePropertyPath 方法: SerializedObjectHelper.cs 206-283 行
- InsertPropertyValue 方法: SerializedObjectHelper.cs 390-407 行
- ConvertSerializedProperty (Generic/ManagedReference): SerializedObjectHelper.cs 364-377 行
- GetSerializedProperties 遍历集成: SerializedObjectHelper.cs 100-162 行 (核心调用在 154-155 行)

**当前状态**: 方案 2 已实施完成 ✅

**方案 2 实现注意事项与局限**:

1. **不使用反射作为主方案**但可使用反射,只要不滥用即可

   - 本实现基于 Unity SerializedObject 系统, 不过度依赖反射 API
   - 优点: 避免滥用反射带来的性能开销, 无需处理私有字段的可见性问题
   - 局限: 只能访问可序列化的字段, 非 SerializeField 的私有字段无法获取
   - 替代方案: 如需访问所有字段, 可补充基于反射的实现作为可选路径
   - **反射使用场景**: 反射仅用于 includePrivateFields 参数的私有字段过滤 (SerializedObjectHelper.cs 118-129 行), 主属性序列化逻辑完全基于 SerializedObject/SerializedProperty, 符合 "不使用反射作为主方案" 的约束

2. **保持 JsonData 类型一致性的重要性**

   - 所有节点必须明确设置 JsonType (Object 或 Array), 否则可能导致插入失败
   - Generic/ManagedReference 等容器类型必须在 ConvertSerializedProperty 中预先创建为 Object 类型
   - 插入数组元素时, 父节点必须确保为 Array 类型 (在 InsertPropertyValue 中处理)
   - 类型不一致会导致 LitJson2_utf 序列化异常或生成错误的 JSON 结构

3. **数组场景避免重复插入**

   - Unity SerializedProperty 遍历时, 同一数组的所有元素会分别遍历
   - 例如: `array.data[0]`, `array.data[1]`, `array.size` 会作为独立 property
   - InsertPropertyValue 通过 ArrayIndex token 区分不同元素, 正确保存在同一数组节点
   - 关键逻辑: 在 SetFinalValue 中检查节点类型, 复用已存在的数组而非重复创建

4. **ManagedReference 输出结构说明**

   - ManagedReference 类型返回包含两个字段的对象容器:
     ```json
     {
       "managedReferenceFullTypename": "Namespace.TypeName, AssemblyName",
       "managedReferenceId": 12345
       // 子属性将填充在此对象中
     }
     ```
   - managedReferenceFullTypename 为类型完整限定名, 包含程序集信息
   - managedReferenceId 为 Unity 内部引用 ID, 用于追踪引用关系
   - 实际字段值由后续子属性填充, 保持与 Unity Inspector 显示一致

5. **Generic/Array/ManagedReference 类型转换为容器的处理策略**

   - **Generic 类型**:

     - 返回空 Object 容器, 不写任何默认值
     - 由子属性逐步填充, 保持树结构的完整性
     - 避免在 default 分支返回占位符字符串导致结构破坏

   - **Array 类型**:

     - ConvertSerializedProperty 返回 ArraySize token 对应的整数 (数组长度)
     - 数组元素由后续 `array.data[index]` 子属性填充
     - InsertPropertyValue 自动将父节点转换为 Array 类型并扩容

   - **ManagedReference 类型**:

     - 返回包含类型信息的 Object 容器
     - 类型字段 (managedReferenceFullTypename/managedReferenceId) 在 ConvertSerializedProperty 中一次性设置
     - 实际对象字段由后续子属性填充, 保持类型信息与值的分离

   - **统一策略**:
     - 所有容器类型都不在 ConvertSerializedProperty 中写默认字符串
     - 避免在 InsertPropertyValue 中触发类型冲突
     - 确保树结构按深度优先顺序正确构建

====================================已完成=============================