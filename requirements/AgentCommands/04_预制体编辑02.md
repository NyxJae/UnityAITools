# 需求文档 - 预制体编辑功能(GameObject 删除、移动与复制)

## 1. 项目现状与核心目标

### 1.1 用户需求简述

需要提供两个命令来编辑 Unity 预制体中的 GameObject 层级结构:

1. **prefab.deleteGameObject**: 删除预制体中的指定 GameObject(级联删除其所有子物体)
2. **prefab.moveOrCopyGameObject**: 移动或复制预制体中的 GameObject 到新的父节点, 可指定在父节点子物体列表中的位置

### 1.2 项目现状

- 项目已有完善的 AgentCommands 命令系统, 位于 `Code/Assets/Editor/AgentCommands/`
- 已实现预制体查看功能: `prefab.queryHierarchy` 和 `prefab.queryComponents`
- 已实现预制体属性修改功能: `prefab.setGameObjectProperties`
- 已有模块化工具类: PrefabLoader, GameObjectPathFinder, SerializedObjectHelper 等
- 本命令需要与预制体查看功能搭配使用: 先用 `prefab.queryHierarchy` 查询获取 GameObject 的路径, 再用本命令进行删除、移动或复制
- **插件化架构**: prefab 命令通过 `AgentCommands.Plugins.Prefab.PrefabCommandsPlugin` 提供(Priority 20)
- **实现文件**: `Code/Assets/Editor/AgentCommands/Plugins/Prefab/PrefabCommandsPlugin.cs`

### 1.3 核心目标

- 让外部工具通过写入批量命令的方式, 向 Unity Editor 发起"删除、移动或复制预制体中 GameObject"的请求
- 删除操作支持级联删除(删除父物体时自动删除所有子物体)
- 移动操作支持指定目标父节点和子物体索引位置
- **复制操作支持复制 GameObject 到新的父节点, 原对象保持不变**
- 移动/复制后自动保存预制体到磁盘
- 移动/复制时保持世界坐标不变(自动调整 transform 以保持物体在世界坐标系中的位置)
- 返回操作后的结果信息, 便于验证操作是否成功

## 2. 范围与边界

### 2.1 功能点简述

本需求包含以下两个独立命令:

#### 命令 1: prefab.deleteGameObject

- [ ] 接收预制体路径和 GameObject 路径, 定位目标对象
- [ ] 删除目标 GameObject 及其所有子物体(级联删除)
- [ ] 使用 Unity 的 Undo 系统, 支持撤销操作
- [ ] 修改后自动保存预制体到磁盘
- [ ] 返回删除操作的结果信息(删除的对象数量, 路径等)

#### 命令 2: prefab.moveOrCopyGameObject

- [ ] 接收预制体路径, 源 GameObject 路径, 目标父节点路径
- [ ] 根据参数决定是移动还是复制 GameObject(及其所有子物体)到新的父节点下
- [ ] 可指定在目标父节点子物体列表中的位置(targetSiblingIndex)
- [ ] 移动/复制时保持世界坐标不变(自动调整 transform)
- [ ] 使用 Unity 的 Undo 系统, 支持撤销操作
- [ ] 修改后自动保存预制体到磁盘
- [ ] 返回操作后的结果信息(新旧路径, 索引, 操作类型等)

### 2.2 排除项

- 不支持删除或移动预制体根节点(根节点必须存在)
- 不支持跨预制体移动 GameObject(所有操作都在同一个预制体内)
- 不支持复制到原父节点(复制操作的目标父节点必须与源父节点不同)
- 不支持重排序 GameObject 的独立命令(移动命令已包含此功能)

## 3. 举例覆盖需求和边缘情况

### 3.1 命令 1: prefab.deleteGameObject 示例

#### 输入示例

```json
{
  "batchId": "batch_delete_001",
  "timeout": 30000,
  "commands": [
    {
      "id": "cmd_delete_button",
      "type": "prefab.deleteGameObject",
      "params": {
        "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
        "objectPath": "DialogMain/Panel_Content/K3Button_Confirm"
      }
    }
  ]
}
```

#### 输出示例

```json
{
  "batchId": "batch_delete_001",
  "status": "completed",
  "startedAt": "2026-02-02 10:00:00.000",
  "finishedAt": "2026-02-02 10:00:01.200",
  "results": [
    {
      "id": "cmd_delete_button",
      "type": "prefab.deleteGameObject",
      "status": "success",
      "startedAt": "2026-02-02 10:00:00.100",
      "finishedAt": "2026-02-02 10:00:01.000",
      "result": {
        "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
        "deletedObjectPath": "DialogMain/Panel_Content/K3Button_Confirm",
        "deletedInstanceID": 345678901,
        "deletedObjectCount": 1,
        "totalDeletedCount": 1,
        "saved": true
      }
    }
  ],
  "totalCommands": 1,
  "successCount": 1,
  "failedCount": 0
}
```

#### 边缘情况示例

**例 1: 删除包含子物体的 GameObject(级联删除)**

```json
{
  "params": {
    "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
    "objectPath": "DialogMain/Panel_Content"
  }
}
```

- 假设 `Panel_Content` 包含 3 个子物体: `K3Button_Confirm`, `K3Button_Cancel`, `K3Label_Title`
- 预期:
- `Panel_Content` 及其所有子物体(共 4 个 GameObject)被删除
- `totalDeletedCount = 4` (1 个父物体 + 3 个子物体)
- `deletedObjectCount = 1` (表示用户明确指定的删除对象数量)

**例 2: 删除不存在的 GameObject**

```json
{
  "params": {
    "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
    "objectPath": "DialogMain/NotExistNode"
  }
}
```

- 预期:
- `status=error`
- `error.code=RUNTIME_ERROR`
- `error.message="GameObject not found at path: DialogMain/NotExistNode"`

**例 3: 删除预制体根节点(应该失败)**

```json
{
  "params": {
    "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
    "objectPath": "DialogMain"
  }
}
```

- 预期:
- `status=error`
- `error.code=RUNTIME_ERROR`
- `error.message="CANNOT_DELETE_ROOT: 不能删除预制体根节点: DialogMain"`

**例 4: 删除同名 GameObject(使用 siblingIndex)**

```json
{
  "params": {
    "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
    "objectPath": "DialogMain/Panel_Content/K3Button_Confirm",
    "siblingIndex": 1
  }
}
```

- 假设 `Panel_Content` 下有两个 `K3Button_Confirm` (siblingIndex 分别为 0 和 1)
- 预期:
- 删除第二个 `K3Button_Confirm` (siblingIndex=1)
- 第一个 `K3Button_Confirm` 保持不变

### 3.2 命令 2: prefab.moveOrCopyGameObject 示例

#### 输入示例 (移动操作)

```json
{
  "batchId": "batch_move_001",
  "timeout": 30000,
  "commands": [
    {
      "id": "cmd_move_button",
      "type": "prefab.moveOrCopyGameObject",
      "params": {
        "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
        "sourcePath": "DialogMain/Panel_Content/K3Button_Confirm",
        "targetParentPath": "DialogMain/Panel_Other",
        "targetSiblingIndex": 0,
        "isCopy": false
      }
    }
  ]
}
```

#### 输出示例 (移动操作)

```json
{
  "batchId": "batch_move_001",
  "status": "completed",
  "startedAt": "2026-02-02 10:00:00.000",
  "finishedAt": "2026-02-02 10:00:01.500",
  "results": [
    {
      "id": "cmd_move_button",
      "type": "prefab.moveOrCopyGameObject",
      "status": "success",
      "startedAt": "2026-02-02 10:00:00.100",
      "finishedAt": "2026-02-02 10:00:01.300",
      "result": {
        "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
        "sourcePath": "DialogMain/Panel_Content/K3Button_Confirm",
        "oldPath": "DialogMain/Panel_Content/K3Button_Confirm",
        "newPath": "DialogMain/Panel_Other/K3Button_Confirm",
        "oldSiblingIndex": 2,
        "newSiblingIndex": 0,
        "operationType": "move",
        "worldPositionPreserved": true,
        "operatedInstanceID": 345678901,
        "saved": true
      }
    }
  ],
  "totalCommands": 1,
  "successCount": 1,
  "failedCount": 0
}
```

#### 输入示例 (复制操作)

```json
{
  "batchId": "batch_copy_001",
  "timeout": 30000,
  "commands": [
    {
      "id": "cmd_copy_button",
      "type": "prefab.moveOrCopyGameObject",
      "params": {
        "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
        "sourcePath": "DialogMain/Panel_Content/K3Button_Confirm",
        "targetParentPath": "DialogMain/Panel_Other",
        "targetSiblingIndex": 0,
        "isCopy": true
      }
    }
  ]
}
```

#### 输出示例 (复制操作)

```json
{
  "batchId": "batch_copy_001",
  "status": "completed",
  "startedAt": "2026-02-02 10:00:00.000",
  "finishedAt": "2026-02-02 10:00:01.500",
  "results": [
    {
      "id": "cmd_copy_button",
      "type": "prefab.moveOrCopyGameObject",
      "status": "success",
      "startedAt": "2026-02-02 10:00:00.100",
      "finishedAt": "2026-02-02 10:00:01.300",
      "result": {
        "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
        "sourcePath": "DialogMain/Panel_Content/K3Button_Confirm",
        "originalPath": "DialogMain/Panel_Content/K3Button_Confirm",
        "copiedPath": "DialogMain/Panel_Other/K3Button_Confirm",
        "sourceSiblingIndex": 2,
        "targetSiblingIndex": 0,
        "operationType": "copy",
        "worldPositionPreserved": true,
        "originalInstanceID": 345678901,
        "copiedInstanceID": 345678902,
        "saved": true
      }
    }
  ],
  "totalCommands": 1,
  "successCount": 1,
  "failedCount": 0
}
```

#### 边缘情况示例

**例 5: 移动物体到末尾(不指定 targetSiblingIndex)**

```json
{
  "params": {
    "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
    "sourcePath": "DialogMain/Panel_Content/K3Button_Confirm",
    "targetParentPath": "DialogMain/Panel_Other"
  }
}
```

- 预期:
- 物体被移动到 `Panel_Other` 的子物体列表末尾
- `newSiblingIndex` 为目标父节点的子物体数量(即最后一个位置)

**例 6: 移动物体时 targetSiblingIndex 超出范围**

```json
{
  "params": {
    "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
    "sourcePath": "DialogMain/Panel_Content/K3Button_Confirm",
    "targetParentPath": "DialogMain/Panel_Other",
    "targetSiblingIndex": 999
  }
}
```

- 假设 `Panel_Other` 只有 3 个子物体(有效索引范围为 0-3)
- 预期:
- 自动将物体移动到末尾(索引 3)
- `newSiblingIndex = 3`
- 不会报错, 自动修正到有效范围

**例 7: 移动物体到其自身的子节点(应该失败)**

```json
{
  "params": {
    "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
    "sourcePath": "DialogMain/Panel_Content",
    "targetParentPath": "DialogMain/Panel_Content/K3Button_Confirm"
  }
}
```

- 预期:
- `status=error`
- `error.code=RUNTIME_ERROR`
- `error.message="CANNOT_MOVE_TO_SELF_OR_CHILD: 不能将物体移动到其自身或其子节点下: DialogMain/Panel_Content"`

**例 8: 移动携带子物体的 GameObject**

```json
{
  "params": {
    "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
    "sourcePath": "DialogMain/Panel_Content",
    "targetParentPath": "DialogMain/Panel_Other",
    "targetSiblingIndex": 0
  }
}
```

- 假设 `Panel_Content` 包含 3 个子物体
- 预期:
- `Panel_Content` 及其所有子物体一起移动到 `Panel_Other` 下
- 移动后, `Panel_Content` 的子物体仍然保持在其下方
- 保持世界坐标不变, 物体在 Unity Scene 视图中的位置看起来没有变化

**例 9: 源 GameObject 不存在**

```json
{
  "params": {
    "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
    "sourcePath": "DialogMain/NotExistNode",
    "targetParentPath": "DialogMain/Panel_Other"
  }
}
```

- 预期:
- `status=error`
- `error.code=RUNTIME_ERROR`
- `error.message="GameObject not found at path: DialogMain/NotExistNode"`

**例 10: 复制 GameObject**

```json
{
  "params": {
    "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
    "sourcePath": "DialogMain/Panel_Content/K3Button_Confirm",
    "targetParentPath": "DialogMain/Panel_Other",
    "targetSiblingIndex": 0,
    "isCopy": true
  }
}
```

- 假设 `Panel_Content` 下有 `K3Button_Confirm` (siblingIndex=2)
- 预期:
- 复制一个新的 `K3Button_Confirm` 到 `Panel_Other` 下(索引 0)
- 原来的 `K3Button_Confirm` 保持在 `Panel_Content` 下不变
- 返回 `originalInstanceID` 和 `copiedInstanceID` 两个不同的实例 ID
- `operationType = "copy"`

**例 11: 复制携带子物体的 GameObject**

```json
{
  "params": {
    "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
    "sourcePath": "DialogMain/Panel_Content",
    "targetParentPath": "DialogMain/Panel_Other",
    "targetSiblingIndex": 0,
    "isCopy": true
  }
}
```

- 假设 `Panel_Content` 包含 3 个子物体
- 预期:
- 复制 `Panel_Content` 及其所有子物体到 `Panel_Other` 下
- 原来的 `Panel_Content` 及其子物体保持不变
- 保持世界坐标不变, 复制的物体在 Unity Scene 视图中的位置与原物体重叠

**例 12: 复制到原父节点(应该失败)**

```json
{
  "params": {
    "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
    "sourcePath": "DialogMain/Panel_Content/K3Button_Confirm",
    "targetParentPath": "DialogMain/Panel_Content",
    "isCopy": true
  }
}
```

- 预期:
- `status=error`
- `error.code=RUNTIME_ERROR`
- `error.message="CANNOT_COPY_TO_SAME_PARENT: 不能将GameObject复制到其原父节点下"`

**例 13: 目标父节点不存在**

```json
{
  "params": {
    "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
    "sourcePath": "DialogMain/Panel_Content/K3Button_Confirm",
    "targetParentPath": "DialogMain/NotExistNode"
  }
}
```

- 预期:
- `status=error`
- `error.code=RUNTIME_ERROR`
- `error.message="GameObject not found at path: DialogMain/NotExistNode"`

### 3.3 复杂场景示例

**例 14: 与 prefab.queryHierarchy 搭配使用**

典型工作流程:

1. 先查询预制体层级:

```json
{
  "batchId": "batch_query_001",
  "commands": [
    {
      "id": "cmd_query",
      "type": "prefab.queryHierarchy",
      "params": {
        "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab"
      }
    }
  ]
}
```

2. 从查询结果中获取 GameObject 的路径, 然后删除、移动或复制:

```json
{
  "batchId": "batch_delete_001",
  "commands": [
    {
      "id": "cmd_delete",
      "type": "prefab.deleteGameObject",
      "params": {
        "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
        "objectPath": "DialogMain/Panel_Content/K3Button_Confirm"
      }
    }
  ]
}
```

或移动:

```json
{
  "batchId": "batch_move_001",
  "commands": [
    {
      "id": "cmd_move",
      "type": "prefab.moveOrCopyGameObject",
      "params": {
        "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
        "sourcePath": "DialogMain/Panel_Content/K3Button_Confirm",
        "targetParentPath": "DialogMain/Panel_Other",
        "targetSiblingIndex": 0,
        "isCopy": false
      }
    }
  ]
}
```

或复制:

```json
{
  "batchId": "batch_copy_001",
  "commands": [
    {
      "id": "cmd_copy",
      "type": "prefab.moveOrCopyGameObject",
      "params": {
        "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
        "sourcePath": "DialogMain/Panel_Content/K3Button_Confirm",
        "targetParentPath": "DialogMain/Panel_Other",
        "targetSiblingIndex": 0,
        "isCopy": true
      }
    }
  ]
}
```

**例 15: 批量操作多个 GameObject(删除)**

```json
{
  "batchId": "batch_multi_delete_001",
  "commands": [
    {
      "id": "cmd_delete_1",
      "type": "prefab.deleteGameObject",
      "params": {
        "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
        "objectPath": "DialogMain/Panel_Content/K3Button_Confirm"
      }
    },
    {
      "id": "cmd_delete_2",
      "type": "prefab.deleteGameObject",
      "params": {
        "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
        "objectPath": "DialogMain/Panel_Content/K3Button_Cancel"
      }
    },
    {
      "id": "cmd_delete_3",
      "type": "prefab.deleteGameObject",
      "params": {
        "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
        "objectPath": "DialogMain/Panel_Other/K3Label_Title"
      }
    }
  ]
}
```

- 预期:
- 3 个 GameObject 按顺序被删除
- `totalCommands=3`, `successCount=3`, `failedCount=0`
- 所有删除操作在同一个预制体上执行, 最终保存一次

**例 16: 批量操作多个 GameObject(移动)**

```json
{
  "batchId": "batch_multi_move_001",
  "commands": [
    {
      "id": "cmd_move_1",
      "type": "prefab.moveOrCopyGameObject",
      "params": {
        "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
        "sourcePath": "DialogMain/Panel_Content/K3Button_Confirm",
        "targetParentPath": "DialogMain/Panel_Other",
        "targetSiblingIndex": 0,
        "isCopy": false
      }
    },
    {
      "id": "cmd_move_2",
      "type": "prefab.moveOrCopyGameObject",
      "params": {
        "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
        "sourcePath": "DialogMain/Panel_Content/K3Button_Cancel",
        "targetParentPath": "DialogMain/Panel_Other",
        "targetSiblingIndex": 1,
        "isCopy": false
      }
    }
  ]
}
```

- 预期:
- 两个 GameObject 按顺序移动
- 第一个移动到索引 0, 第二个移动到索引 1
- 移动后, `Panel_Other` 下的子物体顺序为: `K3Button_Confirm`(索引 0), `K3Button_Cancel`(索引 1)

**例 17: 批量操作多个 GameObject(复制)**

```json
{
  "batchId": "batch_multi_copy_001",
  "commands": [
    {
      "id": "cmd_copy_1",
      "type": "prefab.moveOrCopyGameObject",
      "params": {
        "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
        "sourcePath": "DialogMain/Panel_Content/K3Button_Confirm",
        "targetParentPath": "DialogMain/Panel_Other",
        "targetSiblingIndex": 0,
        "isCopy": true
      }
    },
    {
      "id": "cmd_copy_2",
      "type": "prefab.moveOrCopyGameObject",
      "params": {
        "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
        "sourcePath": "DialogMain/Panel_Content/K3Button_Confirm",
        "targetParentPath": "DialogMain/Panel_Other",
        "targetSiblingIndex": 1,
        "isCopy": true
      }
    }
  ]
}
```

- 预期:
- 复制两个 `K3Button_Confirm` 到 `Panel_Other` 下
- 原来的 `K3Button_Confirm` 保持在 `Panel_Content` 下不变
- `Panel_Other` 下现在有两个复制出的 `K3Button_Confirm`

**例 18: 移动同名 GameObject(使用 siblingIndex)**

```json
{
  "params": {
    "prefabPath": "Assets/ResourcesAB/UIPrefabs/DialogMain.prefab",
    "sourcePath": "DialogMain/Panel_Content/K3Button_Confirm",
    "sourceSiblingIndex": 1,
    "targetParentPath": "DialogMain/Panel_Other",
    "targetSiblingIndex": 0,
    "isCopy": false
  }
}
```

- 假设 `Panel_Content` 下有两个 `K3Button_Confirm` (siblingIndex 分别为 0 和 1)
- 预期:
- 移动第二个 `K3Button_Confirm` (sourceSiblingIndex=1)
- 第一个 `K3Button_Confirm` 保持不变

## 4. 参数汇总

### 4.1 prefab.deleteGameObject 参数

| 参数名       | 类型   | 必填 | 默认值 | 说明                                      |
| ------------ | ------ | ---- | ------ | ----------------------------------------- |
| prefabPath   | string | 是   | -      | 预制体绝对路径                            |
| objectPath   | string | 是   | -      | GameObject 层级路径                       |
| siblingIndex | int    | 否   | 0      | 同名对象索引(从 0 开始), 用于定位同名对象 |

### 4.2 prefab.moveOrCopyGameObject 参数

| 参数名             | 类型   | 必填 | 默认值 | 说明                                                    |
| ------------------ | ------ | ---- | ------ | ------------------------------------------------------- |
| prefabPath         | string | 是   | -      | 预制体绝对路径                                          |
| sourcePath         | string | 是   | -      | 源 GameObject 层级路径(要移动或复制的物体)              |
| sourceSiblingIndex | int    | 否   | 0      | 源 GameObject 同名对象索引(从 0 开始), 用于定位同名对象 |
| targetParentPath   | string | 是   | -      | 目标父节点 GameObject 层级路径                          |
| targetSiblingIndex | int    | 否   | -1     | 在目标父节点子物体列表中的位置, -1 表示移动到末尾       |
| isCopy             | bool   | 否   | false  | true=复制操作, false=移动操作                           |

**参数说明**:

- `sourceSiblingIndex`: 当源路径下存在多个同名 GameObject 时, 用于精确定位要移动/复制的对象
- `targetSiblingIndex`:
- 指定物体在目标父节点子物体列表中的位置
- 从 0 开始(0=第一个子物体, 1=第二个子物体, 以此类推)
- 默认值 -1 表示移动到末尾
- 如果超出范围, 自动修正到有效范围(移动到末尾)
- `isCopy`:
- `false` (默认): 移动操作, 将源对象从原位置移动到新位置
- `true`: 复制操作, 在新位置创建源对象的副本, 原对象保持不变
- 复制操作时, 目标父节点必须与源父节点不同

## 5. 验收清单(可执行)

### 5.1 批量命令框架相关

- [ ] 往 `pending/` 放入 1 个合法批量命令, json 会被处理, `results/` 先出现 processing 再变 completed
- [ ] 批量命令中的删除/移动/复制命令执行成功后, `results` 数组中对应元素的 `status=success`
- [ ] 批量命令的批次级别统计字段正确: `totalCommands`, `successCount`, `failedCount`
- [ ] 部分成功模式: 某个删除/移动/复制命令失败时, 后续命令继续执行

### 5.2 prefab.deleteGameObject 功能相关

**基本功能:**

- [ ] 删除单个 GameObject, `result.deletedObjectPath` 显示被删除对象的路径
- [ ] 删除包含子物体的 GameObject, `result.totalDeletedCount` 正确统计删除的总数
- [ ] 返回的 `result.saved=true` 表示预制体已保存到磁盘
- [ ] 删除后重新查询预制体, 被删除的对象不再存在

**错误处理:**

- [ ] 预制体路径不存在时, 返回 `status=error`, `error.code=PREFAB_NOT_FOUND`
- [ ] GameObject 路径不存在时, 返回 `status=error`, `error.code=GAMEOBJECT_NOT_FOUND`
- [ ] 尝试删除预制体根节点时, 返回 `status=error`, `error.code=CANNOT_DELETE_ROOT`

**边缘情况:**

- [ ] 删除同名 GameObject(使用 siblingIndex), 只删除指定索引的对象
- [ ] 批量删除多个 GameObject, 所有命令按顺序执行
- [ ] 批量命令中部分删除失败时, 其他删除命令继续执行

### 5.3 prefab.moveOrCopyGameObject 功能相关

**基本功能 (移动):**

- [ ] 移动 GameObject 到新的父节点, `result.newPath` 显示新路径
- [ ] 移动携带子物体的 GameObject, 所有子物体一起移动
- [ ] 指定 targetSiblingIndex, 物体移动到正确的位置
- [ ] 不指定 targetSiblingIndex, 物体移动到末尾
- [ ] 返回的 `result.operationType="move"` 表示移动操作
- [ ] 返回的 `result.worldPositionPreserved=true` 表示保持了世界坐标
- [ ] 返回的 `result.saved=true` 表示预制体已保存到磁盘
- [ ] 移动后重新查询预制体, 对象在新位置且子物体保持完整

**基本功能 (复制):**

- [ ] 复制 GameObject 到新的父节点, `result.copiedPath` 显示新副本路径
- [ ] 复制携带子物体的 GameObject, 所有子物体一起被复制
- [ ] 指定 targetSiblingIndex, 副本放置到正确的位置
- [ ] 不指定 targetSiblingIndex, 副本放置到末尾
- [ ] 返回的 `result.operationType="copy"` 表示复制操作
- [ ] 返回的 `result.originalInstanceID` 和 `result.copiedInstanceID` 分别为原对象和副本的实例 ID
- [ ] 返回的 `result.worldPositionPreserved=true` 表示保持了世界坐标
- [ ] 返回的 `result.saved=true` 表示预制体已保存到磁盘
- [ ] 复制后重新查询预制体, 原对象保持不变, 新副本出现在目标位置

**错误处理:**

- [ ] 预制体路径不存在时, 返回 `status=error`, `error.code=PREFAB_NOT_FOUND`
- [ ] 源 GameObject 路径不存在时, 返回 `status=error`, `error.code=GAMEOBJECT_NOT_FOUND`
- [ ] 目标父节点路径不存在时, 返回 `status=error`, `error.code=GAMEOBJECT_NOT_FOUND`
- [ ] 尝试将物体移动到其自身或子节点时, 返回 `status=error`, `error.code=CANNOT_MOVE_TO_SELF_OR_CHILD`
- [ ] 尝试将物体复制到其原父节点时, 返回 `status=error`, `error.code=CANNOT_COPY_TO_SAME_PARENT`

**边缘情况:**

- [ ] targetSiblingIndex 超出范围时, 自动修正到有效范围(移动到末尾)
- [ ] 移动/复制同名 GameObject(使用 sourceSiblingIndex), 只操作指定索引的对象
- [ ] 批量移动/复制多个 GameObject, 所有命令按顺序执行
- [ ] 批量命令中部分移动/复制失败时, 其他命令继续执行

### 5.4 集成测试

- [ ] 先用 `prefab.queryHierarchy` 查询预制体, 再用删除/移动命令操作, 工作流程正常
- [ ] 操作后重新查询预制体, 层级结构正确反映修改结果
- [ ] 在 Unity Editor 中手动打开预制体, 确认修改已正确保存
- [ ] 使用 Unity 的撤销功能(Ctrl+Z), 可以撤销删除或移动操作

## 6. 技术实现要点

### 6.1 实现方案

**删除操作:**

- 复用现有的模块化工具类: PrefabLoader, GameObjectPathFinder 等
- 使用 `Undo.DestroyObjectImmediate()` 删除 GameObject, 支持 Undo 系统
- 删除前记录 GameObject 路径和 InstanceID, 用于返回结果
- 递归统计子物体数量, 用于返回 totalDeletedCount
- 修改后使用 `PrefabUtility.SaveAsPrefabAsset()` 保存预制体
- 使用 `AssetDatabase.Refresh()` 刷新资产数据库

**复制操作:**

- 复用现有的模块化工具类: PrefabLoader, GameObjectPathFinder 等
- 使用 `UnityEditor.Instantiate.Instantiate()` 或 `GameObject.Instantiate()` 复制 GameObject
- 使用 `Undo.RegisterCreatedObjectUndo()` 注册 Undo 操作, 支持撤销
- 复制前记录原对象的世界坐标, 复制后设置到副本以保持世界坐标不变
- 使用 `transform.SetSiblingIndex()` 设置副本在目标父节点子物体列表中的位置
- 修改后使用 `PrefabUtility.SaveAsPrefabAsset()` 保存预制体
- 使用 `AssetDatabase.Refresh()` 刷新资产数据库

### 6.2 代码组织建议

```
Assets/Editor/AgentCommands/Plugins/Prefab/
├── PrefabCommandsPlugin.cs                    # 已有, 注册新命令
└── Handlers/
    ├── PrefabQueryHierarchyHandler.cs       # 已有
    ├── PrefabQueryComponentsHandler.cs      # 已有
    ├── PrefabSetGameObjectPropertiesHandler.cs  # 已有
    ├── PrefabDeleteGameObjectHandler.cs     # 新增
    └── PrefabMoveOrCopyGameObjectHandler.cs    # 新增
```

### 6.3 关键 API

| 功能类别        | API/方法                            | 说明                           |
| --------------- | ----------------------------------- | ------------------------------ |
| 预制体加载      | `PrefabLoader.LoadPrefab()`         | 复用现有工具                   |
| 对象定位        | `GameObjectPathFinder.FindByPath()` | 复用现有工具                   |
| 删除 GameObject | `Undo.DestroyObjectImmediate()`     | 删除对象并支持 Undo            |
| 修改父节点      | `Undo.SetTransformParent()`         | 修改父节点并支持 Undo          |
| 复制 GameObject | `GameObject.Instantiate()`          | 复制 GameObject                |
| 注册 Undo       | `Undo.RegisterCreatedObjectUndo()`  | 为新创建的对象注册 Undo        |
| 设置子物体索引  | `transform.SetSiblingIndex()`       | 设置在父节点子物体列表中的位置 |
| 获取世界坐标    | `transform.position`                | 获取世界坐标                   |
| 设置世界坐标    | `transform.position`                | 设置世界坐标                   |
| 预制体保存      | `PrefabUtility.SaveAsPrefabAsset()` | 保存预制体到磁盘               |
| 刷新数据库      | `AssetDatabase.Refresh()`           | 刷新资产数据库                 |

### 6.4 参数验证要点

**删除操作验证:**

- 验证预制体路径存在且有效
- 验证 GameObject 路径存在且可定位
- 验证不是预制体根节点(根节点不能删除)

**移动/复制操作验证:**

- 验证预制体路径存在且有效
- 验证源 GameObject 路径存在且可定位
- 验证目标父节点路径存在且可定位
- 验证不是将物体移动到其自身或其子节点下(会形成循环引用)
- 验证复制操作的目标父节点与源父节点不同(复制到原父节点无意义)
- 验证 targetSiblingIndex 在有效范围内(或自动修正到末尾)

### 6.5 批量操作的顺序依赖问题

**问题描述:**

批量删除、移动或复制时, 前序操作会改变预制体的层级结构, 可能导致后续操作的路径失效。

**典型场景:**

```json
{
  "commands": [
    {
      "id": "cmd_1",
      "type": "prefab.deleteGameObject",
      "params": {
        "objectPath": "DialogMain/Panel_Content" // 删除父节点
      }
    },
    {
      "id": "cmd_2",
      "type": "prefab.deleteGameObject",
      "params": {
        "objectPath": "DialogMain/Panel_Content/K3Button_Confirm" // 错误！父节点已被删除
      }
    }
  ]
}
```

**cmd_2 会失败**, 因为 `Panel_Content` 已经被 cmd_1 删除了。

**处理策略:**

**策略 1: 智能验证机制(推荐实现)**

每个命令执行前, 先验证目标物体是否存在:

```csharp
// 删除操作
GameObject targetGO = GameObjectPathFinder.FindByPath(prefabRoot, objectPath, siblingIndex);
if (targetGO == null)
{
    // 返回已删除的错误, 但不中断批次执行
    return BuildError("GAMEOBJECT_ALREADY_DELETED", "对象已被前面的操作删除: " + objectPath);
}

// 移动操作 - 每次都重新查询路径
GameObject sourceGO = GameObjectPathFinder.FindByPath(prefabRoot, sourcePath, sourceSiblingIndex);
GameObject targetParentGO = GameObjectPathFinder.FindByPath(prefabRoot, targetParentPath, -1);
if (sourceGO == null || targetParentGO == null)
{
    // 返回路径失效的错误
    return BuildError("GAMEOBJECT_PATH_CHANGED", "对象路径已被前面的操作改变: " + path);
}
```

**错误处理原则:**

- 命令失败时, 记录错误但不中断批次执行(部分成功模式)
- 错误信息明确说明是"已删除"或"路径已改变", 便于用户理解
- 批次最终返回 `successCount` 和 `failedCount`, 用户可以看到哪些操作成功了

**策略 2: 文档明确说明(必须添加)**

在技能文档和使用指南中明确说明:

**⚠️ 批量操作顺序注意事项:**

1. **删除操作**: 建议按照"从叶子节点到父节点"的顺序删除

   - ✅ 正确: 先删除 `Panel_Content/K3Button_Confirm`, 再删除 `Panel_Content`
   - ❌ 错误: 先删除 `Panel_Content`, 再删除其子节点(会失败)

2. **移动操作**: 建议使用 `instanceID` 或在每次移动前重新查询路径

   - 如果移动操作改变了父节点的子物体数量, 后续的 `targetSiblingIndex` 可能需要调整
   - 建议将移动操作按照"从深到浅"的顺序执行

3. **混合操作**: 删除和移动混合时, 删除优先执行
   - 如果要删除某个节点下的多个子节点, 再删除该节点本身, 分成两个批次执行
   - 第一个批次: 删除所有叶子节点
   - 第二个批次: 删除父节点

**策略 3: 技术文档示例(必须添加)**

在需求文档中添加批量操作的示例:

```json
{
  "batchId": "batch_delete_correct_001",
  "commands": [
    {
      "id": "cmd_delete_leaf_1",
      "type": "prefab.deleteGameObject",
      "params": {
        "objectPath": "DialogMain/Panel_Content/K3Button_Confirm"
      }
    },
    {
      "id": "cmd_delete_leaf_2",
      "type": "prefab.deleteGameObject",
      "params": {
        "objectPath": "DialogMain/Panel_Content/K3Button_Cancel"
      }
    },
    {
      "id": "cmd_delete_parent",
      "type": "prefab.deleteGameObject",
      "params": {
        "objectPath": "DialogMain/Panel_Content" // 最后删除父节点
      }
    }
  ]
}
```

**实现要求:**

- [ ] PrefabDeleteGameObjectHandler: 每次删除前检查物体是否还存在
- [ ] PrefabMoveOrCopyGameObjectHandler: 每次移动/复制前重新查询源物体和目标父节点路径
- [ ] 错误信息区分"不存在"(初始就不存在)和"已删除"(被前面的操作删除)
- [ ] 技能文档添加"⚠️ 批量操作顺序注意事项"章节
- [ ] 提供正确和错误的批量操作示例对比

### 6.6 保持世界坐标不变的实现

**关键代码逻辑(伪代码):**

```csharp
// 1. 记录移动前的世界坐标
Vector3 oldWorldPosition = sourceGO.transform.position;
Quaternion oldWorldRotation = sourceGO.transform.rotation;
Vector3 oldWorldScale = sourceGO.transform.lossyScale;

// 2. 修改父节点
Undo.SetTransformParent(sourceGO.transform, newParent.transform, "Move GameObject");

// 3. 恢复世界坐标
sourceGO.transform.position = oldWorldPosition;
sourceGO.transform.rotation = oldWorldRotation;
// lossyScale 是只读的, 需要通过 localScale 恢复
Vector3 newLocalScale = CalculateLocalScale(newParent, oldWorldScale);
sourceGO.transform.localScale = newLocalScale;

// 4. 设置子物体索引
if (targetSiblingIndex >= 0 && targetSiblingIndex < newParent.transform.childCount)
{
    sourceGO.transform.SetSiblingIndex(targetSiblingIndex);
}
else
{
    // 自动移动到末尾(targetSiblingIndex 超出范围或未指定)
    sourceGO.transform.SetAsLastSibling();
}
```

**注意:** lossyScale 是只读属性, 需要根据父物体的 scale 反向计算 localScale 来恢复世界坐标系的缩放。

## 7. 与其他命令的关系

### 7.1 命令依赖关系

- `prefab.queryHierarchy`: 提供预制体层级结构查询, 为删除、移动和复制操作提供对象路径
- `prefab.queryComponents`: 提供组件查询, 可用于确认删除前对象的组件信息
- `prefab.setGameObjectProperties`: 提供属性修改, 可在移动/复制后调整对象属性

### 7.2 典型使用流程

**场景 1: 删除不需要的 UI 元素**

1. 使用 `prefab.queryHierarchy` 查看预制体结构
2. 找到要删除的 UI 元素路径
3. 使用 `prefab.deleteGameObject` 删除该元素
4. 使用 `prefab.queryHierarchy` 再次查询, 确认删除成功

**场景 2: 调整 UI 布局**

1. 使用 `prefab.queryHierarchy` 查看预制体结构
2. 使用 `prefab.moveOrCopyGameObject` 将 UI 元素移动到合适的父节点
3. 使用 `prefab.moveOrCopyGameObject` 调整 UI 元素在父节点下的顺序(通过 targetSiblingIndex)
4. 使用 `prefab.setGameObjectProperties` 调整 UI 元素的属性(如 layer, isActive 等)
5. 使用 `prefab.queryHierarchy` 再次查询, 确认修改成功

**场景 3: 复制 UI 元素**

1. 使用 `prefab.queryHierarchy` 查看预制体结构
2. 使用 `prefab.moveOrCopyGameObject` 复制 UI 元素到目标位置(isCopy=true)
3. 使用 `prefab.setGameObjectProperties` 调整副本的属性(如重命名)
4. 使用 `prefab.queryHierarchy` 再次查询, 确认复制成功

**场景 4: 批量重构预制体**

1. 使用 `prefab.queryHierarchy` 分析当前预制体结构
2. 使用批量删除命令清理不需要的旧元素
3. 使用批量移动命令重新组织元素层级
4. 使用批量复制命令创建新的 UI 元素副本
5. 使用 `prefab.setGameObjectProperties` 批量调整属性
6. 使用 `prefab.queryHierarchy` 最终确认结构正确性

====================================已完成=============================
