# 需求文档

## 1. 项目现状与核心目标

本需求用于实现一个 Unity Editor 插件(编辑器侧常驻工具),在 Unity 启动后自动运行,监听项目内 `Assets/AgentCommands/pending/` 目录新增的 `.json` 命令文件,并以“先写处理中结果,再写最终结果,最后归档命令文件”的方式可靠地完成命令处理.

核心目标:

- 让外部工具/脚本只需要往 `pending/` 丢一个 json,就能触发 Unity Editor 在后台处理.
- 在 Unity 域重载(脚本重编译,进入/退出 PlayMode 等)情况下,不丢命令,不重复产生不可控副作用,并且不发生线程泄漏/内存泄漏.
- 采用可扩展的模块化结构,便于后续新增更多 `type` 的命令处理器.
- 首期支持 1 个命令: 日志查询(`log.query`),其功能需求详见 `requirements/AgentCommands/02_日志功能需求_log.query.md`.

已知项目惯例/可参考点(用于实现阶段对齐):

- 项目内已有 `[InitializeOnLoad]` 方式自动启动 Editor 功能的案例.
- 项目内日志规范存在 `GameLog`(输出到 Unity Console)等实现.

## 2. 范围与边界

**目录约定(必须):**

- 插件 C# 源码放置: `Assets/Editor/AgentCommands/`.
- 插件工作目录(数据目录): `Assets/AgentCommands/`.
- 数据子目录(若不存在必须自动创建):
  - `Assets/AgentCommands/pending/` (输入队列)
  - `Assets/AgentCommands/results/` (输出结果,最多保留最近 20 条)
  - `Assets/AgentCommands/done/` (归档备份,平铺存放)

**功能点(本期必须):**

- [ ] Unity Editor 启动后自动启动插件,并开始监听 `pending/`.
- [ ] 启动/重启(域重载)时,自动扫描 `pending/` 中未完成的 json,继续处理.
- [ ] 发现 `pending/` 中存在待处理 json 时,按“单线程串行”策略处理(同时最多 1 个命令).
- [ ] 每个命令开始处理时,先在 `results/` 写入“半成品(处理中)json”作为处理中的标识.
- [ ] 处理完成后,覆盖写入 `results/` 中对应 json 为最终结果.
- [ ] 处理成功或失败后,将 `pending/` 中对应 json 移动到 `done/` 归档.
- [ ] 插件整体采用模块化/插件化架构,命令按 `type` 分发到不同处理器.

**非功能性要求(本期必须):**

- [ ] 域重载安全: 不产生线程溢出/内存溢出,不产生重复注册的回调,不导致编辑器卡死.
- [ ] 禁止重复注册: 任何 `FileSystemWatcher`,`EditorApplication.update`,`Application.logMessageReceived` 等回调注册必须保证幂等(例如先反注册再注册,或使用静态标记),避免域重载后重复触发导致重复处理/性能问题.
- [ ] 稳定性: 即使处理中崩溃/重启,也能通过 `pending/` + `results/` 状态恢复并继续.
- [ ] 可审计: `results/` 中结果必须包含清晰的状态与时间信息(便于排查).

**排除项(本期明确不做):**

- 不实现运行时(Play 模式或打包后)命令处理,仅限 Unity Editor.
- 不实现跨机器通信,只基于项目目录的文件输入输出.
- 不实现“并发处理多个命令”.
- 不实现日志的“跨启动回溯文件查询”(只查本次编辑器启动后的实时日志缓存).

## 3. 命令文件协议(输入 pending json)

**文件位置与后缀:**

- 输入文件必须放在 `Assets/AgentCommands/pending/`.
- 后缀必须是 `.json`.

**最小字段(必须):**

- `type`: string,命令类型,用于分发处理器.首期定义 `log.query`.
- `params`: object,命令参数(不同 `type` 含义不同).

**时间戳来源(必须):**

- pending json 不再要求提供 `createdAt` 字段.
- 插件以命令文件的文件系统元数据作为审计与排序参考:
  - 优先使用文件创建时间(CreationTime).
  - 若无法可靠获取,使用最后写入时间(LastWriteTime)作为兜底.

**写入未完成重试(必须):**

- 为避免外部工具“先创建文件,再分段写入内容”导致短暂的不可解析,插件在读取 pending 文件失败时必须重试(轻量指数退避):
  - 该重试参数为实现层常量(例如 `ReadRetryDelaysMs=[1000,2000,4000]`),可由开发者在代码中调整(本期默认如示例).
  - 最多重试 3 次.
  - 间隔依次为: 1000ms,2000ms,4000ms.
  - 若重试后仍不可解析,才按 `INVALID_JSON` 处理并归档.

**文件命名规则(必须):**

- 文件名必须为 `{id}.json`,其中 `id` 即文件名去掉 `.json` 的部分.
- 插件以文件名解析得到 `id`,json 内容中不要求提供 `id` 字段.

**id 生成建议(建议):**

- `id` 由写入 pending json 的外部工具/Agent 生成,不要求有序,只要求全局尽量不重复.
- 不要求日期前缀(因为 done 不再按日期分组,且旧记录会被自动清理).
- 建议使用随机 ID,且只包含文件名安全字符(推荐 `[a-zA-Z0-9_-]`),避免空格与特殊字符.
- 推荐长度: 16-32 个字符.
- 示例(任选一种风格,保持一致):
  - 类 nanoid 风格: `pD3k9aQm_7F2wXbTn1c8`.

## 4. 结果文件协议(输出 results json)

**文件位置:** `Assets/AgentCommands/results/`.

**文件命名(必须):**

- `results/{id}.json`.

**结果结构(必须):**

- `id`: string,命令唯一标识,等于输入文件名解析得到的 `id`.
- `type`: string,同输入.
- `status`: string,仅允许:
  - `processing`: 已开始处理,仍在处理中(半成品).
  - `success`: 已成功完成.
  - `error`: 已失败完成.
- `startedAt`: string,开始处理时间.
- `finishedAt`: string,处理完成时间(仅在 success/error 时必须存在).
- `error`: object,仅在 `status=error` 时必须存在:
  - `code`: string,可用于分类(例如 `INVALID_JSON`,`UNKNOWN_TYPE`,`RUNTIME_ERROR`).
  - `message`: string,对非专业人士可读的错误说明.
  - `detail`: string,可选,用于开发排查的额外信息(例如堆栈摘要).
- `result`: object,仅在 `status=success` 时必须存在,承载具体业务结果.

**半成品(处理中)规则(必须):**

- `results/` 中最多保留最近 20 条最终结果(success/error). 当写入新的最终结果后,如果超出 20 条,必须删除最老的结果文件.
  - 同时删除 `done/` 中同名归档命令文件(即原始 pending json 的备份).
  - 该 20 为实现层常量(例如 `MaxResults=20`),可由开发者在代码中调整(本期默认 20).
  - 仅对最终结果(success/error)参与计数与清理,`processing` 不参与计数,避免处理中被误删.
  - “最老”按 `results/{id}.json` 的文件创建时间(CreationTime)判断(若无法可靠获取,用 LastWriteTime 兜底).

- 在域重载后重新启动插件时,如果发现 `pending/` 仍存在同一个命令文件,则允许覆盖 `results/{id}.json` 为新的 `processing`(表示继续处理).
- 为避免外部读取到半截 json,写入 results 建议采用原子写: 先写临时文件(例如 `.tmp`),再 rename 覆盖为最终文件.

**常量配置(实现要求):**

- 需要将 `MaxResults` 与 `ReadRetryDelaysMs` 等参数集中放在单独的 C# 文件中(例如 `AgentCommandsConfig.cs`),以便开发者调整(不提供外部配置文件).

## 5. 文件流转与状态机

**处理顺序(必须):**

- 单线程串行处理.
- 当 `pending/` 同时存在多个文件,按“文件创建时间从早到晚”处理(若无法可靠获取,则按文件名排序作为兜底,实现阶段需注明).

**处理流程(必须):**

1. 发现待处理 `pending/{id}.json`.
2. 读取并解析 json.
3. 若 json 不可解析,或缺少最小字段(例如缺 `type`/`params`):
   - 直接写入 `results/{id}.json` 为 `status=error`(不写 processing),用于告知外部“命令文件格式不正确".
   - `error.code` 使用 `INVALID_JSON` 或 `INVALID_FIELDS`.
   - 然后将 `pending/{id}.json` 移动到 `done/{id}.json` 归档.
4. 若校验通过,写入 `results/{id}.json` 半成品: `status=processing`.

5. 执行成功:
   - 覆盖写入 `results/{id}.json` 为 `status=success` + `result`.
6. 执行失败(未知 type/运行异常等):
   - 覆盖写入 `results/{id}.json` 为 `status=error` + `error`.
7. 无论成功或失败,将 `pending/{id}.json` 移动到 `done/{id}.json`.

**恢复机制(必须):**

- Unity Editor 启动/脚本重编译后插件重新加载时,必须扫描 `pending/`:
  - 如果存在文件,说明命令尚未归档,必须继续处理.
  - 即使 `results/{id}.json` 已存在并且是 `processing`,也必须以当前重启为准继续处理,并可覆盖更新 `startedAt`.

## 6. 模块化/可扩展性要求

**命令分发(必须):**

- 插件必须按 `type` 查找对应“命令处理器”.
- 每个处理器只负责自己的 `params` 解析,执行,以及构造 `result` 或 `error`.

**新增命令的方式(必须):**

- 新增一个命令类型时,无需改动核心监听与文件流转逻辑.
- 仅需:
  - 注册新的 `type`.
  - 实现对应处理器.

## 7. 举例覆盖需求和边缘情况(框架通用)

**例 6: json 文件写入未完成就被监听到**

- 场景:
  - 外部程序正在写 `pending/cmd_002.json`,Unity 监听到 Created/Changed 事件时文件内容还不完整.
- 预期:
  - 插件应具备“重试/延迟处理”策略,避免因为短暂的半写入导致永久失败.

**例 7: 域重载中断处理**

- 场景:
  - 已写出 `results/cmd_003.json` 为 `processing`,但 Unity 因脚本重编译域重载.
- 预期:
  - 重启后扫描 `pending/` 仍发现 `cmd_003.json`,继续处理并最终归档.

**例 8: 未知 type**

- 输入:
  - `type`: `scene.build`
- 预期:
  - `results/{id}.json` 写 `status=error`,`error.code=UNKNOWN_TYPE`.
  - 仍然移动到 `done/` 归档.

## 8. 验收清单(可执行)

- [ ] 删除 `Assets/AgentCommands/` 后重新打开 Unity,目录会自动创建完整.
- [ ] 往 `pending/` 放入 1 个合法 `log.query` 命令,json 会被处理,`results/` 先出现 processing 再变 success,命令文件被移动到 `done/`.
- [ ] 在处理过程中触发域重载(例如修改脚本触发重编译),插件重启后能继续处理并最终归档.

- [ ] 传入非法 json/非法 regex/未知 type,会得到 `status=error` 的结构化错误,并且命令文件仍会被归档.
- [ ] 连续放入 21 个合法命令并等待全部处理完成,当第 21 个命令完成后,最老的 1 个 results 和对应的 done 同名归档会被自动删除(results 中始终保留最新的 20 条最终结果).
- [ ] 在处理过程中检查 `results/` 目录,即使已有 20 条或更多结果,`processing` 状态的结果文件也不会被清理;只有 `success` 或 `error` 的最终结果才参与计数和清理.
