# 需求文档

## 1. 项目现状与核心目标

本需求用于实现一个 Unity Editor 插件(编辑器侧常驻工具),在 Unity 启动后自动运行,监听项目内 `Assets/AgentCommands/pending/` 目录新增的 `.json` 命令文件,并以“先写处理中结果,再写最终结果,最后归档命令文件”的方式可靠地完成命令处理.

核心目标:

- 让外部工具/脚本只需要往 `pending/` 丢一个 json,就能触发 Unity Editor 在后台处理.
- 在 Unity 域重载(脚本重编译,进入/退出 PlayMode 等)情况下,不丢命令,不重复产生不可控副作用,并且不发生线程泄漏/内存泄漏.
- 采用可扩展的模块化结构,便于后续新增更多 `type` 的命令处理器.
- 首期支持 1 个命令: 日志查询(`log.query`),其功能需求详见 `requirements/AgentCommands/02_日志功能需求_log.query.md`.

已知项目惯例/可参考点(用于实现阶段对齐):

- 项目内已有 `[InitializeOnLoad]` 方式自动启动 Editor 功能的案例.
- 项目内日志规范存在 `GameLog`(输出到 Unity Console)等实现.

## 2. 范围与边界

**目录约定(必须):**

- 插件 C# 源码放置: `Assets/Editor/AgentCommands/`.
- 插件工作目录(数据目录): `Assets/AgentCommands/`.
- 数据子目录(若不存在必须自动创建):
  - `Assets/AgentCommands/pending/` (输入队列)
  - `Assets/AgentCommands/results/` (输出结果,最多保留最近 20 条)
  - `Assets/AgentCommands/done/` (归档备份,平铺存放)

**功能点(本期必须):**

- [ ] Unity Editor 启动后自动启动插件,并开始监听 `pending/`.
- [ ] 启动/重启(域重载)时,自动扫描 `pending/` 中未完成的 json,继续处理.
- [ ] 发现 `pending/` 中存在待处理 json 时,按“单线程串行”策略处理(同时最多 1 个命令).
- [ ] 每个命令开始处理时,先在 `results/` 写入“半成品(处理中)json”作为处理中的标识.
- [ ] 处理完成后,覆盖写入 `results/` 中对应 json 为最终结果.
- [ ] 处理成功或失败后,将 `pending/` 中对应 json 移动到 `done/` 归档.
- [ ] 插件整体采用模块化/插件化架构,命令按 `type` 分发到不同处理器.

**非功能性要求(本期必须):**

- [ ] 域重载安全: 不产生线程溢出/内存溢出,不产生重复注册的回调,不导致编辑器卡死.
- [ ] 禁止重复注册: 任何 `FileSystemWatcher`,`EditorApplication.update`,`Application.logMessageReceived` 等回调注册必须保证幂等(例如先反注册再注册,或使用静态标记),避免域重载后重复触发导致重复处理/性能问题.
- [ ] 稳定性: 即使处理中崩溃/重启,也能通过 `pending/` + `results/` 状态恢复并继续.
- [ ] 可审计: `results/` 中结果必须包含清晰的状态与时间信息(便于排查).

**排除项(本期明确不做):**

- 不实现运行时(Play 模式或打包后)命令处理,仅限 Unity Editor.
- 不实现跨机器通信,只基于项目目录的文件输入输出.
- 不实现“并发处理多个命令”.
- 不实现日志的“跨启动回溯文件查询”(只查本次编辑器启动后的实时日志缓存).

## 3. 命令文件协议(输入 pending json)

**重要说明**: 本插件**仅支持批量命令格式**,即使只执行一个命令也必须使用批量格式.

**文件位置与后缀:**

- 输入文件必须放在 `Assets/AgentCommands/pending/`.
- 后缀必须是 `.json`.

**文件命名规则(必须):**

- 文件名必须为 `{batchId}.json`,其中 `batchId` 即文件名去掉 `.json` 的部分.
- 插件以文件名解析得到 `batchId`,json 内容中不要求提供 `batchId` 字段.

**batchId 生成建议(建议):**

- `batchId` 由写入 pending json 的外部工具/Agent 生成,不要求有序,只要求全局尽量不重复.
- 只包含文件名安全字符(推荐 `[a-zA-Z0-9_-]`),避免空格与特殊字符.
- 推荐长度: 16-32 个字符.
- 示例: `batch_log_001`, `batch_error_qa2k3m9x`.

**最小字段(必须):**

- `batchId`: string,批次唯一标识,用作文件名 `{batchId}.json`.
- `commands`: array,必填.命令数组,每个元素是一个完整的命令对象.

**命令对象字段(每个元素):**

- `id`: string,必填.命令唯一标识,由调用方提供,用于在结果中匹配每个命令.
- `type`: string,必填.命令类型,用于分发处理器.首期定义 `log.query`.
- `params`: object,必填.命令参数,具体内容由命令类型决定.
- `timeout`: number,可选.命令级别超时时间(毫秒),优先级高于批次级别,默认 null(使用批次级别值).

**批次级别字段(可选):**

- `timeout`: number,可选.批次级别超时时间(毫秒),默认 30000(30 秒).

**时间戳来源(必须):**

- pending json 不再要求提供 `createdAt` 字段.
- 插件以命令文件的文件系统元数据作为审计与排序参考:
  - 优先使用文件创建时间(CreationTime).
  - 若无法可靠获取,使用最后写入时间(LastWriteTime)作为兜底.

**写入未完成重试(必须):**

- 为避免外部工具“先创建文件,再分段写入内容”导致短暂的不可解析,插件在读取 pending 文件失败时必须重试(轻量指数退避):
  - 该重试参数为实现层常量(例如 `ReadRetryDelaysMs=[1000,2000,4000]`),可由开发者在代码中调整(本期默认如示例).
  - 最多重试 3 次.
  - 间隔依次为: 1000ms,2000ms,4000ms.
  - 若重试后仍不可解析,才按 `INVALID_JSON` 处理并归档.

**文件命名规则(必须):**

- 文件名必须为 `{id}.json`,其中 `id` 即文件名去掉 `.json` 的部分.
- 插件以文件名解析得到 `id`,json 内容中不要求提供 `id` 字段.

**id 生成建议(建议):**

- `id` 由写入 pending json 的外部工具/Agent 生成,不要求有序,只要求全局尽量不重复.
- 不要求日期前缀(因为 done 不再按日期分组,且旧记录会被自动清理).
- 建议使用随机 ID,且只包含文件名安全字符(推荐 `[a-zA-Z0-9_-]`),避免空格与特殊字符.
- 推荐长度: 16-32 个字符.
- 示例(任选一种风格,保持一致):
  - 类 nanoid 风格: `pD3k9aQm_7F2wXbTn1c8`.

## 4. 结果文件协议(输出 results json)

**文件位置:** `Assets/AgentCommands/results/`.

**文件命名(必须):**

- `results/{batchId}.json`.

**批次级别结果结构(必须):**

- `batchId`: string,批次唯一标识(与输入一致).
- `status`: string,批次状态,仅允许:
  - `processing`: 批次正在执行中.
  - `completed`: 批次执行完成(包括全部成功或部分成功).
  - `error`: 批次级别错误(如 JSON 解析失败,字段缺失等).
- `startedAt`: string,批次开始执行时间戳.
- `finishedAt`: string,批次完成执行时间戳.
- `results`: array,命令结果数组,顺序与输入 `commands` 顺序一致.
- `totalCommands`: number,总命令数.
- `successCount`: number,成功执行的命令数.
- `failedCount`: number,失败的命令数.
- `error`: object,仅在 `status=error` 时必须存在:
  - `code`: string,可用于分类(例如 `INVALID_JSON`,`INVALID_FIELDS`,`UNKNOWN_TYPE`).
  - `message`: string,对非专业人士可读的错误说明.
  - `detail`: string,可选,用于开发排查的额外信息.

**命令级别结果结构(results 数组中每个元素):**

- `id`: string,命令唯一标识(与输入一致).
- `type`: string,命令类型(与输入一致).
- `status`: string,命令状态,仅允许:
  - `success`: 命令执行成功.
  - `error`: 命令执行失败.
- `startedAt`: string,命令开始执行时间戳.
- `finishedAt`: string,命令完成执行时间戳.
- `result`: object,可选.命令执行成功时的结果数据,内容由命令类型决定.
- `error`: object,可选.命令执行失败时的错误信息,包含:
  - `code`: string,错误码(如 `INVALID_FIELDS`,`INVALID_REGEX`,`TIMEOUT`,`SKIPPED` 等).
  - `message`: string,对非专业人士可读的错误说明.
  - `detail`: string,可选.详细的错误信息或堆栈.

**半成品(处理中)规则(必须):**

- `results/` 中最多保留最近 20 条最终结果(success/error). 当写入新的最终结果后,如果超出 20 条,必须删除最老的结果文件.

  - 同时删除 `done/` 中同名归档命令文件(即原始 pending json 的备份).
  - 该 20 为实现层常量(例如 `MaxResults=20`),可由开发者在代码中调整(本期默认 20).
  - 仅对最终结果(success/error)参与计数与清理,`processing` 不参与计数,避免处理中被误删.
  - “最老”按 `results/{id}.json` 的文件创建时间(CreationTime)判断(若无法可靠获取,用 LastWriteTime 兜底).

- 在域重载后重新启动插件时,如果发现 `pending/` 仍存在同一个命令文件,则允许覆盖 `results/{id}.json` 为新的 `processing`(表示继续处理).
- 为避免外部读取到半截 json,写入 results 建议采用原子写: 先写临时文件(例如 `.tmp`),再 rename 覆盖为最终文件.

**JSON 格式化输出(必须):**

- 返回的 JSON 必须格式化输出,分好行,而非压缩在一行中.
- 是否折叠输出通过代码配置项控制(并非用户配置或请求是可选):
  - 配置项: `AgentCommandsConfig.PrettyPrintJson`
  - 默认值: `true` (不折叠,格式化输出)
  - 实现方式: 使用 LitJson2_utf.JsonWriter 的 PrettyPrint 属性,不引入其他库.

**常量配置(实现要求):**

- 需要将 `MaxResults`、`ReadRetryDelaysMs` 和 `PrettyPrintJson` 等参数集中放在单独的 C# 文件中(例如 `AgentCommandsConfig.cs`),以便开发者调整(不提供外部配置文件).

## 5. 文件流转与状态机

**处理顺序(必须):**

- 单线程串行处理.一次只处理一个批次文件.
- 当 `pending/` 同时存在多个文件,按"文件创建时间从早到晚"处理(若无法可靠获取,则按文件名排序作为兜底,实现阶段需注明).
- 批次内的命令严格按照 `commands` 数组的顺序串行执行,不并行.

**处理流程(必须):**

1. 发现待处理 `pending/{batchId}.json`.
2. 读取并解析 json.
3. 若 json 不可解析,或缺少最小字段(例如缺 `batchId`/`commands`):
   - 直接写入 `results/{batchId}.json` 为 `status=error`(不写 processing),用于告知外部"命令文件格式不正确\".
   - `error.code` 使用 `INVALID_JSON` 或 `INVALID_FIELDS`.
   - 然后将 `pending/{batchId}.json` 移动到 `done/{batchId}.json` 归档.
4. 若校验通过,写入 `results/{batchId}.json` 半成品: `status=processing`, `results=[]`.
5. 串行执行批次内的每个命令:
   - 按顺序执行 `commands` 数组中的每个命令.
   - 每个命令开始时,记录 `startedAt`.
   - 执行成功时,记录 `finishedAt`,添加 `status=success` 和 `result` 到 `results` 数组.
   - 执行失败时,记录 `finishedAt`,添加 `status=error` 和 `error` 到 `results` 数组.
   - **部分成功模式**: 某个命令失败不影响后续命令执行,继续执行剩余命令.
   - **超时处理**:
     - 如果单个命令执行时间超过其 `timeout`,该命令失败(`TIMEOUT` 错误),继续执行后续命令.
     - 如果整个批次执行时间超过批次级别 `timeout`,立即中止执行,未执行的命令标记为 `SKIPPED` 错误.
6. 所有命令执行完毕或批次超时后:
   - 覆盖写入 `results/{batchId}.json` 为 `status=completed`,包含完整的 `results` 数组和统计信息(`totalCommands`,`successCount`,`failedCount`).
7. 无论成功或失败,将 `pending/{batchId}.json` 移动到 `done/{batchId}.json`.

**恢复机制(必须):**

- Unity Editor 启动/脚本重编译后插件重新加载时,必须扫描 `pending/`:
  - 如果存在文件,说明命令尚未归档,必须继续处理.
  - 即使 `results/{batchId}.json` 已存在并且是 `processing`,也必须以当前重启为准继续处理,并可覆盖更新 `startedAt`.

## 6. 模块化/可扩展性要求

**命令分发(必须):**

- 插件必须按 `type` 查找对应“命令处理器”.
- 每个处理器只负责自己的 `params` 解析,执行,以及构造 `result` 或 `error`.

**新增命令的方式(必须):**

- 新增一个命令类型时,无需改动核心监听与文件流转逻辑.
- 仅需:
  - 注册新的 `type`.
  - 实现对应处理器.

## 7. 举例覆盖需求和边缘情况(框架通用)

**例 1: 批量执行多个日志查询命令(全部成功)**

- pending 输入:

```json
{
  "batchId": "batch_error_logs_001",
  "timeout": 60000,
  "commands": [
    {
      "id": "cmd_query_error_50",
      "type": "log.query",
      "params": {
        "n": 50,
        "level": "Error",
        "includeStack": true
      }
    },
    {
      "id": "cmd_query_warning_100",
      "type": "log.query",
      "params": {
        "n": 100,
        "level": "Warning",
        "includeStack": false
      }
    }
  ]
}
```

- 预期 results:
  - `results` 数组包含 2 个元素,顺序与输入一致.
  - `results[0]`: Error 日志查询结果.
  - `results[1]`: Warning 日志查询结果.
  - `totalCommands = 2`, `successCount = 2`, `failedCount = 0`.

**例 2: 部分成功(某些命令失败)**

- pending 输入:

```json
{
  "batchId": "batch_partial_001",
  "commands": [
    {
      "id": "cmd_001",
      "type": "log.query",
      "params": { "n": 10, "level": "Error" }
    },
    {
      "id": "cmd_002",
      "type": "log.query",
      "params": {
        "n": 20,
        "keyword": "[invalid",
        "matchMode": "Regex"
      }
    },
    {
      "id": "cmd_003",
      "type": "log.query",
      "params": { "n": 30, "level": "Warning" }
    }
  ]
}
```

- 预期:
  - `cmd_001`: 成功.
  - `cmd_002`: 失败(正则非法,`INVALID_REGEX`).
  - `cmd_003`: 成功.
  - `totalCommands = 3`, `successCount = 2`, `failedCount = 1`.

**例 3: 命令超时后继续执行**

- pending 输入:

```json
{
  "batchId": "batch_timeout_001",
  "timeout": 30000,
  "commands": [
    {
      "id": "cmd_fast",
      "type": "log.query",
      "params": { "n": 10 },
      "timeout": 5000
    },
    {
      "id": "cmd_normal",
      "type": "log.query",
      "params": { "n": 100 }
    },
    {
      "id": "cmd_slow",
      "type": "log.query",
      "params": { "n": 5000 },
      "timeout": 60000
    }
  ]
}
```

- 预期:
  - `cmd_fast`: 使用命令级别超时 5000ms.
  - `cmd_normal`: 使用批次级别超时 30000ms.
  - `cmd_slow`: 使用命令级别超时 60000ms.
  - 如果 `cmd_normal` 执行超时,该命令失败,但继续执行 `cmd_slow`.

**例 4: 批次级别超时,部分命令未执行**

- pending 输入:

```json
{
  "batchId": "batch_timeout_all_001",
  "timeout": 5000,
  "commands": [
    { "id": "cmd_001", "type": "log.query", "params": { "n": 10 } },
    { "id": "cmd_002", "type": "log.query", "params": { "n": 100 } },
    { "id": "cmd_003", "type": "log.query", "params": { "n": 1000 } },
    { "id": "cmd_004", "type": "log.query", "params": { "n": 10000 } }
  ]
}
```

- 预期:
  - 批次总执行时间超过 5000ms 时立即中止.
  - `cmd_001`, `cmd_002`: 成功(假设已完成).
  - `cmd_003`: 超时失败(`TIMEOUT`).
  - `cmd_004`: 未执行(`SKIPPED`).

**例 5: json 文件写入未完成就被监听到**

- 场景:
  - 外部程序正在写 `pending/cmd_002.json`,Unity 监听到 Created/Changed 事件时文件内容还不完整.
- 预期:
  - 插件应具备"重试/延迟处理"策略,避免因为短暂的半写入导致永久失败.

**例 6: 域重载中断处理**

- 场景:
  - 已写出 `results/cmd_003.json` 为 `processing`,但 Unity 因脚本重编译域重载.
- 预期:
  - 重启后扫描 `pending/` 仍发现 `cmd_003.json`,继续处理并最终归档.

**例 7: 未知 type**

- pending 输入:

```json
{
  "batchId": "batch_unknown_type_001",
  "commands": [
    {
      "id": "cmd_001",
      "type": "log.query",
      "params": { "n": 50 }
    },
    {
      "id": "cmd_002",
      "type": "unknown.command",
      "params": {}
    }
  ]
}
```

- 预期:
  - `cmd_001`: 成功.
  - `cmd_002`: 失败,错误码 `UNKNOWN_TYPE`.

## 8. 验收清单(可执行)

- [ ] 删除 `Assets/AgentCommands/` 后重新打开 Unity,目录会自动创建完整.
- [ ] 往 `pending/` 放入 1 个合法批量命令 json,json 会被处理,`results/` 先出现 processing 再变 completed,命令文件被移动到 `done/`.
- [ ] 批量命令执行后,`results` 数组顺序与输入 `commands` 数组顺序完全一致.
- [ ] 批量命令的批次级别统计字段正确: `totalCommands`,`successCount`,`failedCount`.
- [ ] 部分成功模式: 某个命令失败时,后续命令继续执行,最终返回所有结果.
- [ ] 命令级别 `timeout` 优先级高于批次级别 `timeout`.
- [ ] 命令超时时,该命令失败,但继续执行后续命令.
- [ ] 批次超时时,立即中止执行,返回已完成命令的结果,未执行命令标记为 `SKIPPED` 错误.
- [ ] 命令缺少必填字段时,该命令失败,不影响后续命令.
- [ ] 未知命令类型时,该命令失败,错误码 `UNKNOWN_TYPE`.
- [ ] 正则表达式非法时,该命令失败,错误码 `INVALID_REGEX`.
- [ ] `commands` 数组为空时,批次级别错误,错误码 `INVALID_FIELDS`.
- [ ] `batchId` 字段缺失时,批次级别错误,错误码 `INVALID_FIELDS`.
- [ ] 单个命令也必须使用批量格式(包含 `commands` 数组).
- [ ] 批量执行多个命令时,严格按输入顺序串行执行,不并行.
- [ ] 在处理过程中触发域重载(例如修改脚本触发重编译),插件重启后能继续处理并最终归档.
- [ ] 连续放入 21 个合法批量命令并等待全部处理完成,当第 21 个命令完成后,最老的 1 个 results 和对应的 done 同名归档会被自动删除(results 中始终保留最新的 20 条最终结果).
- [ ] 在处理过程中检查 `results/` 目录,即使已有 20 条或更多结果,`processing` 状态的结果文件也不会被清理;只有 `completed` 的最终结果才参与计数和清理.


====================================已完成=============================
